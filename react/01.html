<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React基础（我认为） | MrXiong</title>
    <meta name="description" content="熊刚的个人博客首页，熊刚的技术作品，熊刚的生活成长">
    <link rel="icon" href="/myBlog/favicon.ico">
  <link rel="manifest" href="/myBlog/manifest.json">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.67215e50.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.9a205e1a.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.c03f67b8.js" as="script"><link rel="preload" href="/myBlog/assets/js/22.5e365889.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.1772eaaa.js"><link rel="prefetch" href="/myBlog/assets/js/11.b72fb48b.js"><link rel="prefetch" href="/myBlog/assets/js/12.c2a1f8a6.js"><link rel="prefetch" href="/myBlog/assets/js/13.8288193b.js"><link rel="prefetch" href="/myBlog/assets/js/14.952ed0f9.js"><link rel="prefetch" href="/myBlog/assets/js/15.c67c2b45.js"><link rel="prefetch" href="/myBlog/assets/js/16.e7bdeb4f.js"><link rel="prefetch" href="/myBlog/assets/js/17.775b6b87.js"><link rel="prefetch" href="/myBlog/assets/js/18.3eb29a8e.js"><link rel="prefetch" href="/myBlog/assets/js/19.21de1f76.js"><link rel="prefetch" href="/myBlog/assets/js/20.94867820.js"><link rel="prefetch" href="/myBlog/assets/js/21.6daa352d.js"><link rel="prefetch" href="/myBlog/assets/js/23.b11b9f1d.js"><link rel="prefetch" href="/myBlog/assets/js/24.b5e770f4.js"><link rel="prefetch" href="/myBlog/assets/js/25.0d01a527.js"><link rel="prefetch" href="/myBlog/assets/js/26.cb940bf6.js"><link rel="prefetch" href="/myBlog/assets/js/27.ed621a85.js"><link rel="prefetch" href="/myBlog/assets/js/28.bcdc172f.js"><link rel="prefetch" href="/myBlog/assets/js/29.da4d0bf3.js"><link rel="prefetch" href="/myBlog/assets/js/3.0f742e16.js"><link rel="prefetch" href="/myBlog/assets/js/30.bbf7f9de.js"><link rel="prefetch" href="/myBlog/assets/js/31.f84eb563.js"><link rel="prefetch" href="/myBlog/assets/js/32.485bc394.js"><link rel="prefetch" href="/myBlog/assets/js/33.69f4ac61.js"><link rel="prefetch" href="/myBlog/assets/js/34.929ce270.js"><link rel="prefetch" href="/myBlog/assets/js/35.ecaae5f1.js"><link rel="prefetch" href="/myBlog/assets/js/36.fb388a85.js"><link rel="prefetch" href="/myBlog/assets/js/37.b0fc1645.js"><link rel="prefetch" href="/myBlog/assets/js/38.22c84c1e.js"><link rel="prefetch" href="/myBlog/assets/js/4.6c9ad4a3.js"><link rel="prefetch" href="/myBlog/assets/js/5.be02b664.js"><link rel="prefetch" href="/myBlog/assets/js/6.99df0c05.js"><link rel="prefetch" href="/myBlog/assets/js/7.872b75e5.js"><link rel="prefetch" href="/myBlog/assets/js/8.997b8e74.js"><link rel="prefetch" href="/myBlog/assets/js/9.3fefe930.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.67215e50.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">MrXiong</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/myBlog/react/" class="nav-link router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/myBlog/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/myBlog/es6/" class="nav-link">ES6</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/node/" class="nav-link">后端及实用技术</a></div><div class="nav-item"><a href="/myBlog/social/" class="nav-link">社交媒体</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/myBlog/react/" class="nav-link router-link-active">React</a></li><li class="dropdown-item"><!----> <a href="/myBlog/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/myBlog/es6/" class="nav-link">ES6</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/node/" class="nav-link">后端及实用技术</a></div><div class="nav-item"><a href="/myBlog/social/" class="nav-link">社交媒体</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/react/" class="sidebar-link">介绍</a></li><li><a href="/myBlog/react/01.html" class="active sidebar-link">React基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#virtual-dom" class="sidebar-link">Virtual DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#diff算法" class="sidebar-link">DIFF算法</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#jsx语法糖" class="sidebar-link">JSX语法糖</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react配置和hello-world" class="sidebar-link">React配置和Hello World</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react配置（webpack）" class="sidebar-link">React配置（webpack）</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#hello-world" class="sidebar-link">Hello World</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#简单介绍jsx语法糖" class="sidebar-link">简单介绍jsx语法糖</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#①-必须被一个单独的大标签包裹" class="sidebar-link">① 必须被一个单独的大标签包裹</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#②-标签必须封闭" class="sidebar-link">② 标签必须封闭</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#③-class要写成classname，for要写成htmlfor" class="sidebar-link">③ class要写成className，for要写成htmlFor</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#④-html注释不能使用，只能使用js注释。" class="sidebar-link">④ HTML注释不能使用，只能使用JS注释。</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#⑤-原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀。" class="sidebar-link">⑤ 原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀。</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#⑥-js表达式用-单大括号包裹" class="sidebar-link">⑥ JS表达式用{}单大括号包裹</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#⑦-可以运行函数：" class="sidebar-link">⑦ 可以运行函数：</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#⑧-样式使用双大括号" class="sidebar-link">⑧ 样式使用双大括号</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#⑨-可以使用数组" class="sidebar-link">⑨ 可以使用数组</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react中的数据传递" class="sidebar-link">React中的数据传递</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#组件自己身上的属性值变化，不会引起视图改变" class="sidebar-link">组件自己身上的属性值变化，不会引起视图改变</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#闭包中的值变化，不会引起视图改变" class="sidebar-link">闭包中的值变化，不会引起视图改变</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#三兄弟之一-：state" class="sidebar-link">三兄弟之一 ：state</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#三兄弟之二-：props" class="sidebar-link">三兄弟之二 ：props</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#三兄弟之三：-context" class="sidebar-link">三兄弟之三： context</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#其他api" class="sidebar-link">其他API;</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#无状态组件" class="sidebar-link">无状态组件</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#默认属性" class="sidebar-link">默认属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#组件的生命周期" class="sidebar-link">组件的生命周期</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react中的表单" class="sidebar-link">React中的表单</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#ref-dom钩子" class="sidebar-link">ref DOM钩子</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#小例子（初级）" class="sidebar-link">小例子（初级）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#调色板" class="sidebar-link">调色板</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#flux设计思想继承" class="sidebar-link">Flux设计思想继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#简介-2" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#从facebook官方实例盘逻辑" class="sidebar-link">从Facebook官方实例盘逻辑</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#redux" class="sidebar-link">Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#基本概念-2" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#通过例子来学习redux" class="sidebar-link">通过例子来学习Redux</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react-redux" class="sidebar-link">React-Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#不使用react-redux遇见的灾难" class="sidebar-link">不使用React-Redux遇见的灾难</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#结合官方文档看官方demo" class="sidebar-link">结合官方文档看官方demo</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#阶段性回顾" class="sidebar-link">阶段性回顾</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#原生react" class="sidebar-link">原生React</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#redux-2" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#组件内部state和全局state" class="sidebar-link">组件内部state和全局state</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react组件封装" class="sidebar-link">React组件封装</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#redux中异步的处理" class="sidebar-link">Redux中异步的处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#bindactioncreators" class="sidebar-link">bindActionCreators</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#combinereducers" class="sidebar-link">combineReducers</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#redux中间件" class="sidebar-link">Redux中间件</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#webpack-dev-server" class="sidebar-link">webpack-dev-server</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#redux-thunk" class="sidebar-link">redux-thunk</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#json-server" class="sidebar-link">JSON-server</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react开发模式" class="sidebar-link">React开发模式</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react路由" class="sidebar-link">React路由</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react-router基本使用" class="sidebar-link">React-router基本使用</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react-router路由规划" class="sidebar-link">React-router路由规划</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#和redux结合" class="sidebar-link">和Redux结合</a></li><li class="sidebar-sub-header"><a href="/myBlog/react/01.html#react-router-2" class="sidebar-link">React-router 2</a></li></ul></li></ul></li><li><a href="/myBlog/react/02.html" class="sidebar-link">React慕课笔记</a></li><li><a href="/myBlog/react/03.html" class="sidebar-link">简书项目</a></li><li><a href="/myBlog/react/04.html" class="sidebar-link">项目心得</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react基础（我认为）"><a href="#react基础（我认为）" aria-hidden="true" class="header-anchor">#</a> React基础（我认为）</h1> <h2 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h2> <p>来自Facebook，2013年诞生。</p> <ul><li><p><strong>和Angular不同，React并不是一个完整的MVC/MVVM框架，它只专注于提供清晰、直接的View视图层解决方案</strong>。它的功能全部以构建组件视图为核心，并提供类似控制器的函数接口和生命周期函数。在React中没有控制器、没有服务、没有指令、没有过滤器等等。</p></li> <li><p><strong>React非常轻</strong>，目标是Minimal API interface（最小化API接口），只提供组件化相关的非常少量的API。<strong>简化了一切可以简化的东西</strong>。比如说Angular中做一个组件，实际上叫做E级别的指令，要写scope、link函数，但是React最大限度的简化了一个组件的开发。事实上React就是为了组件开发而诞生的。</p></li> <li><p><strong>React可以搭配Flux等架构（Redux实现）使用</strong>。有Flux架构护航，数据的单向流动，自称是比MVC、MVVM更高级的一种模式。可以开发大型应用的。</p></li> <li><p><strong>React使用Virtual DOM技术</strong>，使得它性能卓越，开销很小。</p></li></ul> <h2 id="virtual-dom"><a href="#virtual-dom" aria-hidden="true" class="header-anchor">#</a> Virtual DOM</h2> <p>​	Virtual DOM是React中的一个很重要的概念，在日常开发中，前端工程师们需要将后台的数据呈现到界面中，同时要能对用户的操作提供反馈，作用到UI上…… 这些都离不开DOM操作。但是我们知道，<strong>频繁的DOM操作会造成极大的资源浪费，也通常是性能瓶颈的原因。于是React 引入了Virtual DOM。Virtual DOM的核心就是</strong>*计算比较改变前后的DOM区别，然后用最少的DOM操作语句对DOM进行操作。</p> <p>​	比如说要进行这样的DOM转换：</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/VirtualDOM01.png" alt=""></p> <p>不用Virtual DOM技术：删除4个li，插入5个li。</p> <p>使用Virtual DOM技术：通过计算，我们只需要改变4个li的innerHTML，并且插入一个li即可。</p> <h3 id="diff算法"><a href="#diff算法" aria-hidden="true" class="header-anchor">#</a> DIFF算法</h3> <p>Virtual DOM技术使用了DIFF算法，DIFF算法是一个比较计算层次结构区别的算法，现在主要用来计算DOM之间的差异。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/VirtualDOM02.png" alt="用DIFF算法可以计算两个JSON结构之间的差别"></p> <p>用DIFF算法可以计算两个JSON结构之间的差别。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/VirtualDOM03.png" alt=""></p> <p>现在DIFF算法为Virtual DOM技术服务，用来比较DOM结构的差异：</p> <p>如果不使用Virtual DOM技术，此时要删除3个节点，插入3个节点。使用Virtual DOM技术仅仅需要移动节点即可。</p> <h3 id="jsx语法糖"><a href="#jsx语法糖" aria-hidden="true" class="header-anchor">#</a> JSX语法糖</h3> <p><strong>React中使用JSX语法糖</strong>，JSX = JavaScript + XML。js文件中写HTML模板，代码语境不需要来回切换的。也就是说，在Angular中模板写在.html文件中。React中使用.js文件来当做HTML模板，语境是统一的，非常清晰简明。jsx语法比``运算符还要简单，是最优雅的将HTML和JS结合的方案。</p> <p>官网文档：http://reactjs.cn/react/index.html</p> <p>菜鸟教程的文档不错：http://www.runoob.com/react/react-tutorial.html
中文翻译的手册：http://www.css88.com/react/docs/why-react.html</p> <h2 id="react配置和hello-world"><a href="#react配置和hello-world" aria-hidden="true" class="header-anchor">#</a> React配置和Hello World</h2> <h3 id="react配置（webpack）"><a href="#react配置（webpack）" aria-hidden="true" class="header-anchor">#</a> React配置（webpack）</h3> <p>我们创建一个项目文件夹01_HelloWorld，在这个文件夹中，配置webpack + babel环境。让webpack可以指导babel翻译ES6语法。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/VirtualDOM04.png" alt=""></p> <h4 id="基本配置"><a href="#基本配置" aria-hidden="true" class="header-anchor">#</a> 基本配置</h4> <p>创建package.json项目身份证：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm init -y
</code></pre></div><p>安装webpack，并且设置为项目依赖：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm install --save-dev webpack
</code></pre></div><p>当然你必须之前已经在-g下安装过webpack。</p> <p>我们创建一个webpack.config.js文件，这个文件是webpack工作的参考。</p> <p>我们对着https://webpack.js.org/configuration/  这个文档来创建webpack.config.js文件。</p> <p>webpack.config.js文件：</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
module.exports = {
    entry: &quot;./app/main.js&quot;,  
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;all.js&quot;
    }
}
</code></pre></div><p>至此，我们的webpack就已经可以进行标准的CMD模块化开发了。</p> <h4 id="引入es6模块"><a href="#引入es6模块" aria-hidden="true" class="header-anchor">#</a> 引入ES6模块</h4> <p>我们引入babel-loader翻译ES6：</p> <p>我们参考https://github.com/babel/babel-loader 改变webpack.config.js文件：</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
module.exports = {
    entry: &quot;./app/main.js&quot;,  
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;all.js&quot;
    },
    module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /(node_modules|bower_components)/ ,
				use: {
					loader: 'babel-loader',
					options: {
				  		presets: ['es2015']
					}
				}
			}
		]
	}
}
</code></pre></div><p>友情提醒：webpack1和2在配置上差别最大的就是loader的书写方法。module → rules → test/use属性，这是标准webpack2的写法。</p> <p>安装：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm intall --save-dev babel-loader
$ npm intall --save-dev babel-core
$ npm intall --save-dev babel-preset-es2015
</code></pre></div><p>此时运行</p> <p>$ webpack</p> <p>命令，将自动的使用CMD构建app文件夹中main.js文件，并且使用babel翻译。</p> <h4 id="配置react"><a href="#配置react" aria-hidden="true" class="header-anchor">#</a> 配置react</h4> <div class="language- extra-class"><pre class="language-text"><code>$ npm install --save-dev react
$ npm install --save-dev react-dom
$ npm install --save-dev babel-preset-react
</code></pre></div><p>你可能会问：</p> <p>① react为什么不是bower来安装，而是npm来安装</p> <p>② 为什么是save-dev而不是save，也就是说为什么是开发依赖，而不是运行依赖。</p> <p>稍后配置完毕解答。</p> <p>改变webpack.config.js文件，增加一个babel翻译的配置项presets</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');

module.exports = {
    entry: &quot;./app/main.js&quot;,  
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;all.js&quot;
    },
    module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /(node_modules|bower_components)/ ,
				use: {
					loader: 'babel-loader',
					options: {
				  		presets: ['es2015','react']
					}
				}
			}
		]
	}
}
</code></pre></div><p>至此我们已经配置完毕react起步的所有的依赖，我们目前的package.json文件：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;name&quot;: &quot;01&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.24.1&quot;,
    &quot;babel-loader&quot;: &quot;^6.4.1&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,
    &quot;react&quot;: &quot;^15.5.4&quot;,
    &quot;react-dom&quot;: &quot;^15.5.4&quot;,
    &quot;webpack&quot;: &quot;^2.4.1&quot;
  }
}
</code></pre></div><h3 id="hello-world"><a href="#hello-world" aria-hidden="true" class="header-anchor">#</a> Hello World</h3> <p>创建app/App.js文件，这是一个组件：</p> <div class="language- extra-class"><pre class="language-text"><code>import React , {Component} from &quot;react&quot;;
//我们定义一个叫做App的组件，在HTML中可以用&lt;App&gt;&lt;/App&gt;来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends Component{
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return &lt;h1&gt;我是React，很高兴遇见你！说{5000+5000}次我爱你！&lt;/h1&gt;;
	}
}
//向外暴露
export default App;
</code></pre></div><p>下面就要使用这个App组件，所以我们来到/app/main.js文件：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {render} from &quot;react-dom&quot;;
//引入组件
import App from &quot;./App.js&quot;;

//使用、挂载组件，两个参数
//第一个参数是jsx语法
//第二个参数表示组件挂在哪里
render(
	&lt;App&gt;&lt;/App&gt; , 
	document.getElementById(&quot;app-container&quot;)
);
</code></pre></div><h2 id="简单介绍jsx语法糖"><a href="#简单介绍jsx语法糖" aria-hidden="true" class="header-anchor">#</a> 简单介绍jsx语法糖</h2> <table><thead><tr><th>JSX语法翻译前</th> <th>JSX语法翻译后</th></tr></thead> <tbody><tr><td><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/jsxQ.png" alt=""></td> <td><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/jsxH.png" alt=""></td></tr></tbody></table> <p>需要注意：</p> <h3 id="①-必须被一个单独的大标签包裹"><a href="#①-必须被一个单独的大标签包裹" aria-hidden="true" class="header-anchor">#</a> ① <strong>必须被一个单独的大标签包裹</strong></h3> <p>比如div或者section</p> <p>错误的：</p> <div class="language- extra-class"><pre class="language-text"><code>return &lt;h1&gt;我是React，很高兴遇见你！HAHAHAHA&lt;/h1&gt;
&lt;h1&gt;我是React，很高兴遇见你！HAHAHAHA&lt;/h1&gt;;
</code></pre></div><p>正确的：应该被一个div包裹起来，小括号也挺好用的：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
	&lt;div&gt;
		&lt;h1&gt;我是React，很高兴遇见你！HAHAHAHA&lt;/h1&gt;
		&lt;h1&gt;我是React，很高兴遇见你！HAHAHAHA&lt;/h1&gt;
	&lt;/div&gt;
);

</code></pre></div><h3 id="②-标签必须封闭"><a href="#②-标签必须封闭" aria-hidden="true" class="header-anchor">#</a> ② <strong>标签必须封闭</strong></h3> <p>错误的：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
	&lt;div&gt;
		&lt;img src=&quot;&quot; &gt;
	&lt;/div&gt;
);
</code></pre></div><p>正确的：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
	&lt;div&gt;
		&lt;img src=&quot;&quot; /&gt;
	&lt;/div&gt;
);
</code></pre></div><h3 id="③-class要写成classname，for要写成htmlfor"><a href="#③-class要写成classname，for要写成htmlfor" aria-hidden="true" class="header-anchor">#</a> ③ <strong>class要写成className，for要写成htmlFor</strong></h3> <p>错误的：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
	&lt;div&gt;
		&lt;div class=&quot;box&quot; &gt;&lt;/div&gt;
	&lt;/div&gt;
);
</code></pre></div><p>正确的：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
	&lt;div&gt;
		&lt;div className=&quot;box&quot; &gt;&lt;/div&gt;
	&lt;/div&gt;
);
</code></pre></div><h3 id="④-html注释不能使用，只能使用js注释。"><a href="#④-html注释不能使用，只能使用js注释。" aria-hidden="true" class="header-anchor">#</a> ④ HTML注释不能使用，只能使用JS注释。</h3> <h3 id="⑤-原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀。"><a href="#⑤-原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀。" aria-hidden="true" class="header-anchor">#</a> ⑤ <strong>原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀</strong>。</h3> <p>错误：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
			&lt;div&gt;
				&lt;h1&gt;我是React，很高兴遇见你！&lt;/h1&gt;
				&lt;p a=&quot;10&quot;&gt;&lt;/p&gt;
			&lt;/div&gt;
		);
</code></pre></div><p>正确：</p> <div class="language- extra-class"><pre class="language-text"><code>return (
			&lt;div&gt;
				&lt;h1&gt;我是React，很高兴遇见你！&lt;/h1&gt;
				&lt;p data-a=&quot;10&quot;&gt;&lt;/p&gt;
			&lt;/div&gt;
		);
</code></pre></div><p>如果是自定义标签，此时可以随便传属性：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;App a=&quot;123213&quot;&gt;&lt;/App&gt;
</code></pre></div><h3 id="⑥-js表达式用-单大括号包裹"><a href="#⑥-js表达式用-单大括号包裹" aria-hidden="true" class="header-anchor">#</a> ⑥ <strong>JS表达式用{}单大括号包裹</strong></h3> <p>在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h1&gt;我是React，很高兴遇见你！{1+2}&lt;/h1&gt;

{3 &gt; 8 ? &quot;A&quot; : &quot;B&quot;}
</code></pre></div><h3 id="⑦-可以运行函数："><a href="#⑦-可以运行函数：" aria-hidden="true" class="header-anchor">#</a> ⑦ <strong>可以运行函数</strong>：</h3> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
//我们定义一个叫做App的组件，在HTML中可以用&lt;App&gt;&lt;/App&gt;来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends React.Component{
	//定义一个函数haha，接受一个参数
	haha(lanmu){
		if(lanmu == &quot;篮球&quot;){
			return (
					&lt;ul&gt;
						&lt;li&gt;乔丹&lt;/li&gt;
						&lt;li&gt;科比&lt;/li&gt;
						&lt;li&gt;奥尼尔&lt;/li&gt;
					&lt;/ul&gt;
			)
		}else if(lanmu == &quot;足球&quot;){
			return (
				&lt;ul&gt;
					&lt;li&gt;李铁&lt;/li&gt;
					&lt;li&gt;郝海东&lt;/li&gt;
					&lt;li&gt;C罗&lt;/li&gt;
				&lt;/ul&gt;
			)
		}
	}
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			&lt;div&gt;
				&lt;h1&gt;我是React，很高兴遇见你！&lt;/h1&gt;
				&lt;h3&gt;JSX语法很好用哦！&lt;/h3&gt;
				{3 &gt; 8 ? &quot;A&quot; : &quot;B&quot;}
				&lt;h3&gt;JSX可以调用函数哦！&lt;/h3&gt;
				{this.haha(&quot;足球&quot;)}
			&lt;/div&gt;
		);
	}
}
//向外暴露
export default App;
</code></pre></div><h3 id="⑧-样式使用双大括号"><a href="#⑧-样式使用双大括号" aria-hidden="true" class="header-anchor">#</a> ⑧ <strong>样式使用双大括号</strong></h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;JSX可以设置样式哦！&lt;/h3&gt;

&lt;div style={{&quot;width&quot;:&quot;100px&quot;,&quot;height&quot;:20 + 30 + &quot;px&quot;,&quot;backgroundColor&quot; : &quot;red&quot;}}&gt;&lt;/div&gt;

</code></pre></div><h3 id="⑨-可以使用数组"><a href="#⑨-可以使用数组" aria-hidden="true" class="header-anchor">#</a> ⑨ <strong>可以使用数组</strong></h3> <p>数组中如果是JSX语法，数组会被自动展开。所以不需要使用ng-repeat这样的指令展开数组。</p> <div class="language- extra-class"><pre class="language-text"><code>render(){
		//定义一个数组，定义的JSX项目上要求有key属性，只要是重复的数组项目，都要有不能重复的key属性，这是要求。
		let arr = [&quot;白板&quot;,&quot;幺鸡&quot;,&quot;二条&quot;,&quot;三饼&quot;].map((item,index)=&gt;{
			return &lt;li key={index}&gt;{item}&lt;/li&gt;
		});
		//返回一个jsx语法，非常牛逼语法
		return (
			&lt;div&gt;
				&lt;ul&gt;
					{arr}
				&lt;/ul&gt;
			&lt;/div&gt;
		);
	}
</code></pre></div><p>生成:</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/JSXARR.png" alt=""></p> <h2 id="react中的数据传递"><a href="#react中的数据传递" aria-hidden="true" class="header-anchor">#</a> React中的数据传递</h2> <p>​	React中跟数据有关系的就三个东西：state、props、context。我们可以叫做数据传递三兄弟。</p> <h3 id="组件自己身上的属性值变化，不会引起视图改变"><a href="#组件自己身上的属性值变化，不会引起视图改变" aria-hidden="true" class="header-anchor">#</a> 组件自己身上的属性值变化，不会引起视图改变</h3> <p>​	我们可以在组件的类定义里面写constructor构造器，里面定义this.a = 100 。表示给组件的实例绑定一个a属性，值是100。在jsx中使用的时候，直接this.a即可。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
class App extends React.Component{
	//构造函数
	constructor(){
		super();  //要求调用super
		this.a = 100;
	}
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			&lt;div&gt;
				{this.a}
			&lt;/div&gt;
		);
	}
}
//向外暴露
export default App;
</code></pre></div><p>补充知识点super:</p> <div class="language- extra-class"><pre class="language-text"><code>super( ) ——继承
     在class方法中，继承是使用 extends 关键字来实现的。子类 必须 在 constructor( )调用 super( )方法，否则新建实例时会报错。
	报错的原因是：子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。
</code></pre></div><p>我们增加一个按钮，试着让用户点击按钮之后，a的值变化：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
class App extends React.Component{
	//构造函数
	constructor(){
		super();
		this.a = 100;
	}
	add(){
		this.a++;
		console.log(this.a);
	}
	render(){
		return (
			&lt;div&gt;
				&lt;p&gt;{this.a}&lt;/p&gt;
				&lt;p&gt;
				&lt;input type=&quot;button&quot; value=&quot;按我&quot; onClick={(this.add).bind(this)} /&gt;
				&lt;/p&gt;
			&lt;/div&gt;
		);
	}
}
//向外暴露
export default App;
</code></pre></div><p>通过案例学习了：</p> <p>① 绑定监听使用onClick、onMousedown、onMouseenter、onBlur，把on后面的字母大写，React会自动识别React事件。</p> <p>② 绑定监听函数的时候，this上下文是有问题的，所以需要使用bind()方法来设置上下文</p> <p>③ 绑定监听函数的时候，注意用{}而不是&quot;&quot;</p> <p>错误的：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input type=&quot;button&quot; value=&quot;按我&quot; **onClick=****&quot;(this.add).bind(this)&quot;** /&gt;
</code></pre></div><p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/state.png" alt=""></p> <p>所以React中，组件自己的属性的变化不会引发视图的变化！！</p> <h3 id="闭包中的值变化，不会引起视图改变"><a href="#闭包中的值变化，不会引起视图改变" aria-hidden="true" class="header-anchor">#</a> 闭包中的值变化，不会引起视图改变</h3> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
 
class App extends React.Component{
	render(){
		let b = 99;
		return (
			&lt;div&gt;
				&lt;p&gt;{b}&lt;/p&gt;
				&lt;p&gt;
					&lt;input type=&quot;button&quot; value=&quot;按我&quot; onClick={()=&gt;{b++;console.log(b);}} /&gt;
				&lt;/p&gt;
			&lt;/div&gt;
		);
	}
}

//向外暴露
export default App;
闭包中的值变化，也不会引起视图的改变！

</code></pre></div><h3 id="三兄弟之一-：state"><a href="#三兄弟之一-：state" aria-hidden="true" class="header-anchor">#</a> 三兄弟之一 ：state</h3> <p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p> <p>React 里，<strong>只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
 
class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			a : 100,
 			b : 200,
 			c : 300
 		}
 	}
 	add(){
 			this.setState({a : this.state.a + 1});
 	}
 	render(){
 		return (
 			&lt;div&gt;
 				&lt;h1&gt;我是APP组件&lt;/h1&gt;
 				&lt;p&gt;我有状态state&lt;/p&gt;
 				&lt;p&gt;a : {this.state.a}&lt;/p&gt;
 				&lt;p&gt;b : {this.state.b}&lt;/p&gt;
 				&lt;p&gt;c : {this.state.c}&lt;/p&gt;
 				&lt;p&gt;
 					&lt;input type=&quot;button&quot; value=&quot;按我&quot; **onClick={(this.add).bind(this)}**/&gt;
 				&lt;/p&gt;
 			&lt;/div&gt;
 		)
 	}
}

//向外暴露
export default App;
</code></pre></div><p>只有更新三兄弟，才会引发Virtual DOM的改变，从而改变DOM。</p> <ul><li><p>定义state： 在构造函数中使用this.state属性即可</p></li> <li><p>使用state ：在JSX中{this.state.a}</p></li> <li><p>改变state： this.setState({a : this.state.a + 1});  不能写++，因为state属性值只读</p> <pre><code>  state是内部的（所以也叫作local state），**只有组件自己能改变自己的state，别人想改变自己的state，都不可能！**

  后面要介绍Redux架构，所有组件自己的state越来越少用了，而是变为了Redux中的state，不要混淆。
</code></pre></li></ul> <h3 id="三兄弟之二-：props"><a href="#三兄弟之二-：props" aria-hidden="true" class="header-anchor">#</a> 三兄弟之二 ：props</h3> <p>​	就是定义在自定义组件标签上面的值，就是props。当props改变的时候，会引发Virtual DOM的改变，从而引发视图的重绘。react崇尚数据的单向流动，所以设计的时候就是让数据从父组件流向子组件。props在子组件中是只读的，不能修改的。</p> <p>如果父组件App，想往子组件MyCompo中传值，使用属性：</p> <div class="language- extra-class"><pre class="language-text"><code>app/App.js：
import React from &quot;react&quot;;
import MyCompo from &quot;./MyCompo.js&quot;;

class App extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			&lt;div&gt;
 				&lt;MyCompo a=&quot;66&quot; b=&quot;77&quot; c=&quot;88&quot;&gt;&lt;/MyCompo&gt;
 			&lt;/div&gt;
 		)
 	}
}

//向外暴露
export default App;
</code></pre></div><p>子组件MyCompo中就可以无脑使用this.props来枚举传入的属性：</p> <div class="language- extra-class"><pre class="language-text"><code>app/MyCompo.js：
import React from &quot;react&quot;;

class MyCompo extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			&lt;div&gt;
 				我是MyCompo组件
 				&lt;p&gt;{this.props.a}&lt;/p&gt;
 				&lt;p&gt;{this.props.b}&lt;/p&gt;
 				&lt;p&gt;{this.props.c}&lt;/p&gt;
 			&lt;/div&gt;
 		);
 	}
}

//向外暴露
export default MyCompo;
</code></pre></div><p>如果需要在构造函数中使用这个值，此时系统会将props最为构造函数的第一个参数传入：</p> <div class="language- extra-class"><pre class="language-text"><code>class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}
 }
</code></pre></div><p>在子组件中，props是只读的，不能修改props的值。如果要修改，用state来接收。</p> <h4 id="prop-types"><a href="#prop-types" aria-hidden="true" class="header-anchor">#</a> prop-types</h4> <p>props属性可以被验证有效性：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm install --save-dev prop-types
 

import React from &quot;react&quot;;
import { PropTypes } from &quot;prop-types&quot;;

class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}

 	render(){
 		return (
 			&lt;div&gt;
 				我是MyCompo组件
 				&lt;p&gt;{this.props.a}&lt;/p&gt;
 				&lt;p&gt;{this.props.b}&lt;/p&gt;
 				&lt;p&gt;{this.state.c}&lt;/p&gt;
 				&lt;p&gt;
 					&lt;input type=&quot;button&quot; value=&quot;按我&quot; onClick={()=&gt;{this.setState({c : this.state.c + 1});}}/&gt;
 				&lt;/p&gt;
 			&lt;/div&gt;
 		);
 	}
}

//定义组件需要传入的参数，这些都是语法规定
//类名.propTypes，值是一个JSON。key就是需要传进来的props属性名，v就是对它的限制
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,  	//a属性是一个字符串，必传
	b : PropTypes.string,  				//b属性是一个字符串，不必传
	c : PropTypes.number.isRequired		//c属性是一个数组，必传
};

//向外暴露
export default MyCompo;
</code></pre></div><p><strong>如果非要从下到上传输数据呢</strong>？子组件要把数据返回给父组件，此时只能用奇淫技巧。<strong>就是父组件传一个函数给子组件，子组件通过传参数调用函数将数据返回给父组件的函数，父组件的函数接受实参改变父组件中的state等值。</strong></p> <p>父组件App现在想让子组件MyCompo设置App自己的state.d值，此时就需要传入d值，并且传入一个设置d值的函数到子组件：</p> <div class="language- extra-class"><pre class="language-text"><code>app/App.js：
import React from &quot;react&quot;;
import MyCompo from &quot;./MyCompo.js&quot;;

class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			d : 16
 		}
 	}

 	setD(number){
 		this.setState({&quot;d&quot; : number});
 	}

 	render(){
 		return (
 			&lt;div&gt;
 				&lt;p&gt;我是App组件，我有一个d状态：{this.state.d}&lt;/p&gt;
 				&lt;MyCompo setD={(this.setD).bind(this)} d={this.state.d}&gt;&lt;/MyCompo&gt;
 			&lt;/div&gt;
 		)
 	}
}

//向外暴露
export default App;
</code></pre></div><p>子组件就要接受父组件传来的d参数和设置D的函数：</p> <div class="language- extra-class"><pre class="language-text"><code>import React   from &quot;react&quot;;
import { PropTypes } from &quot;prop-types&quot;;

class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 		 	d : props.d
 		}

 		this.add = () =&gt;{
 			this.setState({&quot;d&quot; : this.state.d + 1});
 			props.setD(this.state.d + 1);
 		}
 	}

 	render(){
 		return (
 			&lt;div&gt;
 				&lt;hr/&gt;
 				我是MyCompo组件
 				&lt;p&gt;d : {this.state.d}&lt;/p&gt;
 				&lt;p&gt;
 					&lt;input type=&quot;button&quot; value=&quot;按我更改d的值&quot; **onClick={this.add}**/&gt;
 				&lt;/p&gt;
 			&lt;/div&gt;
 		);
 	}
}

//定义组件需要传入的参数
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,
	b : PropTypes.string.isRequired,
	c : PropTypes.number.isRequired
};
 
//向外暴露
export default MyCompo;

</code></pre></div><p>​	由此可见React是一个特别简单的一个框架，没有Angular或者vue中directive中的scope，@、=、&amp;等等符号。</p> <p>​	数据的单向传递是React的精髓。</p> <p>​	如果通过props传递引用类型数据，此时也是不会垫付“数据单向传递”的限制。子组件中对数组、JSON对象的改变，不会引起父组件中哪个数组、JSON对象的改变，可以认为传入了副本。</p> <h3 id="三兄弟之三：-context"><a href="#三兄弟之三：-context" aria-hidden="true" class="header-anchor">#</a> 三兄弟之三： context</h3> <p>​	上下文的精髓是可以跨级传递数据，爷爷组件可以直接传递数据到孙子组件。</p> <p>语法比较晦涩：</p> <div class="language- extra-class"><pre class="language-text"><code>app/Yeye.js

import React from &quot;react&quot;;
import Baba from &quot;./Baba.js&quot;;
import PropTypes from &quot;prop-types&quot;;

class Yeye extends React.Component{
	constructor(){
		super();
		this.state = {
			a : 100
		}
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;爷爷&lt;/h1&gt;
				&lt;Baba&gt;&lt;/Baba&gt;
			&lt;/div&gt;
		);
	}

	//得到孩子上下文，实际上这里表示一种设置，返回一个对象，这个对象就是现在这个家族体系共享的上下文。将上下文中的a值变为自己的状态中的a值
	getChildContext(){
		return {
			a : this.state.a
		}
	}
}


//设置child的上下文类型
Yeye.childContextTypes = {
	a : PropTypes.number.isRequired
}

export default Yeye;
</code></pre></div><p>app/Baba.js文件，没有写什么东西：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import Sunzi from &quot;./Sunzi&quot;;
import PropTypes from &quot;prop-types&quot;;

class Baba extends React.Component{
	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;爸爸&lt;/h1&gt;
				&lt;Sunzi&gt;&lt;/Sunzi&gt;
			&lt;/div&gt;
		);
	}
}
 
export default Baba;
</code></pre></div><p>app\Sunzi.js</p> <p>React会将上下文当做构造函数的第二个参数传入：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;

class Sunzi extends React.Component{
	constructor(props,context){
		super();
		console.log(context);  //得到上下文
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;孙子&lt;/h1&gt;
			&lt;/div&gt;
		);
	}
}

//设置上下文的类型
Sunzi.contextTypes = {
	a : PropTypes.number
}

export default Sunzi;
</code></pre></div><p>结论：</p> <p>① 当祖先元素中更改了上下文的数据，此时所有的子孙元素中的数据都会更改，视图也会更新；</p> <p>② 反之不成立，可以认为上下文的数据在子孙元素中是只读的。此时又要需要使用奇淫技巧，就是在context中共享一个操作祖先元素的函数，子孙元素通过上下文获得这个函数，从而操作祖先元素的值。</p> <p>也就是说，state是自治的不涉及传值的事儿；props是单向的，父亲→儿子；context也是单向的，祖先→后代。如果要反向，就要传入一个函数。</p> <p>app/Yeye.js：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import Baba from &quot;./Baba.js&quot;;
import PropTypes from &quot;prop-types&quot;;

class Yeye extends React.Component{
	constructor(){
		super();
		this.state = {
			a : 100
		}
	}

	//设置自己的A值，这个函数要进入上下文的“通道”中
	addA(){
		this.setState({a : this.state.a + 1});
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;爷爷{this.state.a} /&gt;&lt;/h1&gt;
				&lt;Baba&gt;&lt;/Baba&gt;
			&lt;/div&gt;
		);
	}
 
	//得到孩子上下文，实际上这里表示一种设置
	getChildContext(){
		return {
			a : this.state.a,
			addA : (this.addA).bind(this)
		}
	}
}

Yeye.childContextTypes = {
	a 		: PropTypes.number.isRequired,
	addA 	: PropTypes.func.isRequired		//func表示函数
}

export default Yeye;
</code></pre></div><p>app/Sunzi.js</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;

class Sunzi extends React.Component{
	constructor(props,context){
		super();
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;孙子{this.context.a} &lt;input type=&quot;button&quot; value=&quot;按我&quot; onClick={this.context.addA}/&gt;&lt;/h1&gt;
			&lt;/div&gt;
		);
	}
}
 
Sunzi.contextTypes = {
	a 		: PropTypes.number,
	addA 	: PropTypes.func
}

export default Sunzi;
</code></pre></div><p>context很少用，传值基本用props。除非特别深的跨级别传值，可以用context。</p> <h2 id="其他api"><a href="#其他api" aria-hidden="true" class="header-anchor">#</a> 其他API;</h2> <h3 id="无状态组件"><a href="#无状态组件" aria-hidden="true" class="header-anchor">#</a> 无状态组件</h3> <p>当我们现在的组件仅仅是为了呈递一些DOM元素，没有state、props等东西，此时可以不用费劲</p> <p>class My extends React.Component{}</p> <p>而是一个暴露简单函数即可：</p> <p>My.js</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;

export default () =&gt; {
	return (
		&lt;div&gt;
			&lt;h1&gt;我是My组件&lt;/h1&gt;
		&lt;/div&gt;
	)
}
</code></pre></div><p>此时真的可以用它：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import My from &quot;./My.js&quot;;

class App extends React.Component{
 	constructor(){
 		super();
 	}

 	render(){
 		return (
 			&lt;div&gt;
 				&lt;My&gt;&lt;/My&gt;
 			&lt;/div&gt;
 		)
 	}
}

//向外暴露
export default App;
</code></pre></div><h3 id="默认属性"><a href="#默认属性" aria-hidden="true" class="header-anchor">#</a> 默认属性</h3> <p>如果没有传入name输入，那么就以“菜鸟”作为属性：</p> <div class="language- extra-class"><pre class="language-text"><code>constructor(props){
	super();
    this.state = {
         name : props.name || &quot;菜鸟&quot;
        }
}
</code></pre></div><h2 id="组件的生命周期"><a href="#组件的生命周期" aria-hidden="true" class="header-anchor">#</a> 组件的生命周期</h2> <p>组件从没有诞生到诞生，到被移除的完整生命周期，都提供了可以触发事件的函数接口，就是生命周期。</p> <p>组件的生命周期包含三个主要部分：</p> <p>挂载： 组件被插入到DOM中。</p> <p>更新： 组件被重新渲染，查明DOM是否应该刷新。</p> <p>移除： 组件从DOM中移除。</p> <p>声明周期函数：</p> <div class="language- extra-class"><pre class="language-text"><code>	//挂载之前
	componentWillMount(){
		console.log(&quot;componentWillMount&quot;);
	}

	//在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。
	componentDidMount(){
		console.log(&quot;componentDidMount&quot;);
	}
 	
 	//当组件做出是否要更新DOM的决定的时候被调用。“门神”，在改变状态的时候可以选择通过或者不通过。
 	shouldComponentUpdate(nextProps , nextState){
 		if(nextState.a &gt; 0.8){
 			return true;
 		}
 		alert(&quot;本次没有随机到大于0.8的，更新被阻止&quot;);
 		return false;
 	}

 	//在更新发生之前被调用，没有把门的功能
 	componentWillUpdate(){
		console.log(&quot;componentWillUpdate&quot;);
 	}

 	//在组件移除和销毁之前被调用
 	componentWillUnmount(){	
 		console.log(&quot;componentWillUnmount&quot;);
 	}
</code></pre></div><h2 id="react中的表单"><a href="#react中的表单" aria-hidden="true" class="header-anchor">#</a> <strong>React中的表单</strong></h2> <p>​	React没有提供类似Angular中复杂的表单验证功能，<strong>也没有双向数据绑定</strong>！</p> <p>​	如果非要做一个效果：文本框中输入内容，实时改变h1中的内容此时就要用模拟的方法，监听文本框的事件，然后改变组件的state状态。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;

class My2 extends React.Component{
	constructor(props){
		super();
	 	this.change = (this.change).bind(this);
	 	this.state = {
	 		&quot;txt&quot; : &quot;&quot;
	 	}
	}
 
	change(event){
		this.setState({&quot;txt&quot; : event.target.value });
	}

	render(){
		return (
			&lt;div&gt;
			 	&lt;input type=&quot;text&quot; onInput={this.change} /&gt;
			 	&lt;h1&gt;{this.state.txt}&lt;/h1&gt;
 			&lt;/div&gt;
		)
	}
}


export default My2;
</code></pre></div><h2 id="ref-dom钩子"><a href="#ref-dom钩子" aria-hidden="true" class="header-anchor">#</a> ref DOM钩子</h2> <p>vue也有：</p> <p><img src="http://m.qpic.cn/psb?/V10cMkGy1fzQni/o2WQ6QBNExRuNzGXLsxe3l4M4wuzRARGurpeSzuqJmk!/b/dE0BAAAAAAAA&amp;bo=rATWAQAAAAADB10!&amp;rf=viewer_4" alt=""></p> <p>有时候需要操作DOM元素，ref属性表示一个钩子。可以在其他地方使用this.refs来获得这个DOM元素。</p> <h2 id="小例子（初级）"><a href="#小例子（初级）" aria-hidden="true" class="header-anchor">#</a> 小例子（初级）</h2> <p>我们硬着头皮上例子，会发现案例感觉react不怎么好用，这是因为它还没有结合Redux，React功力就没有发挥出来。</p> <h3 id="调色板"><a href="#调色板" aria-hidden="true" class="header-anchor">#</a> 调色板</h3> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import Bar from &quot;./components/Bar/Bar.js&quot;;
import &quot;./app.less&quot;;


class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			r : 110,
 			g : 220,
 			b : 130
 		}

 		//三个Bar的实例
 		this.bars = [&quot;r&quot;,&quot;g&quot;,&quot;b&quot;].map((item,index)=&gt;{
 			return &lt;Bar key={index} v={this.state[item]} color={item} setColor={(this.setColor).bind(this)} /&gt;;
 		});
 	}

 	//设置函数，可以设置color颜色为value
 	setColor(color,value) {
 		this.setState({[color] : value});
 	}

 	render(){
 		return (
 			&lt;div&gt;
 				&lt;div className=&quot;box&quot; style={{&quot;backgroundColor&quot; : `rgb(${this.state.r},${this.state.g},${this.state.b})`}}&gt;&lt;/div&gt;
 				{this.bars}
 			&lt;/div&gt;
 		)
 	}
}

//向外暴露
export default App;
</code></pre></div><p>Bar.js：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import &quot;./css.less&quot;;
import {PropTypes} from &quot;prop-types&quot;;

class Bar extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			v : props.v
 		}

 		//绑定this
 		this.change = (this.change).bind(this);
 		this.setColor = props.setColor;
 	}

 	//改变
 	change(event){
 		this.setState({&quot;v&quot; : parseInt(event.target.value)});
 		this.setColor(this.props.color , this.state.v);
 	}

 	render(){
 		return (
 			&lt;div className=&quot;Bar_kaola&quot;&gt;
 				&lt;div className=&quot;bar&quot;&gt;
 					{this.props.color} :
 					&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;255&quot; value={this.state.v} onChange={this.change}/&gt;
 					&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;255&quot; value={this.state.v} onChange={this.change}/&gt;
 				&lt;/div&gt;
 			&lt;/div&gt;
 		)
 	}
}

Bar.propTypes = {
	v 	: PropTypes.number.isRequired,
	color : PropTypes.string.isRequired,
	setColor : PropTypes.func.isRequired
}

//向外暴露
export default Bar;
</code></pre></div><h2 id="flux设计思想继承"><a href="#flux设计思想继承" aria-hidden="true" class="header-anchor">#</a> Flux设计思想继承</h2> <h3 id="简介-2"><a href="#简介-2" aria-hidden="true" class="header-anchor">#</a> 简介</h3> <p>​	传统MVC和MVVM架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动越显得混乱。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/flux01.png" alt=""></p> <p>​	Flux就是致力于解决数据有序传输问题的架构设计模式，来自Facebook，Flux名字是古英语中的flow，就是流动的意思。Flux中最大的哲学就是数据是单向流动的。</p> <p>手册：https://github.com/facebook/flux</p> <p>​	Flux中最重要的四个概念：Dispatcher、Store、View、Action。如果按照MVC的命名方式，Flux应该叫做ADSV模式。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/adsv.png" alt=""></p> <h3 id="基本概念"><a href="#基本概念" aria-hidden="true" class="header-anchor">#</a> 基本概念</h3> <h4 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h4> <ol><li><p>Flux是一个管理App中数据流动的一个模式。</p></li> <li><p>最关键的一个概念就是数据的流动是单向的。</p></li></ol> <h4 id="dispatchererning"><a href="#dispatchererning" aria-hidden="true" class="header-anchor">#</a> Dispatchererning</h4> <ol><li>Dispatcher接收action，并且要把这些action分派给已经注册到Dispatcher的store上。</li> <li>所有的store都将接收所有的action</li> <li>在每个App中，<strong>应该确保只有一个Dispatcher的实例</strong>。</li></ol> <h4 id="store"><a href="#store" aria-hidden="true" class="header-anchor">#</a> Store</h4> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/store01.png" alt=""></p> <ol><li>Store是在App中持有数据的东西。</li> <li>Store们要在App的Dispatcher身上注册，以确保它们可以接收actions。</li> <li><strong>存在store中的数据仅能够因为响应action所改变</strong>。</li> <li>在Store中不能够有公共的setter函数，仅仅能有getter函数。</li> <li>Store们决定了它们愿意响应哪些actions。</li> <li>无论什么时候，store中的数据改变了，就会触发一个change事件</li> <li><strong>在一个App中可能有很多store</strong>。</li></ol> <h4 id="actions"><a href="#actions" aria-hidden="true" class="header-anchor">#</a> Actions</h4> <ol><li>Action定义了我们App中内部的API</li> <li>它们捕获所有可能改变App的任何途径、方法。</li> <li>它们是简单的JSON对象，并且要有&quot;type&quot;属性，和其他的一些数据属性。</li> <li>Action应该有一个具有语义的、直观的表示它是做什么的名字</li> <li>记住，所有的store都将接收同一个action，并且通过这同一个action，store会知道它们要清除、更新哪些数据。</li></ol> <h4 id="views"><a href="#views" aria-hidden="true" class="header-anchor">#</a> Views</h4> <ol><li>从store中来的数据被展示在了view上。</li> <li>View层可以使用任何框架，我们使用React做View层。</li> <li><strong>当一个视图想要是使用从某一个store中来的数据，它必须订阅subscribe（订阅）一下该store的change事件。</strong></li> <li>当store发射了change事件，此时view就能得到新的数据并且重新渲染。</li> <li>如果一个组件要使用store，但是没有订阅这个store，此时等着错误吧！</li> <li>Action最常见的产生原因是在App的某一个部分因用户的交互行为，而被此view dispatch出来了。</li></ol> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/adsv2.png" alt=""></p> <h3 id="从facebook官方实例盘逻辑"><a href="#从facebook官方实例盘逻辑" aria-hidden="true" class="header-anchor">#</a> 从Facebook官方实例盘逻辑</h3> <p>https://github.com/facebook/flux</p> <p>官方demo不看，不如回家卖红薯。</p> <p>下载这个flux git包，然后解压缩，拿出examples/flux-todomvc文件夹。</p> <p>进入这个文件夹，安装package.json中声明的依赖。</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm install
$ npm run build
</code></pre></div><p>此时它自动用webpack构建我们的项目了。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/adsv3.png" alt=""></p> <p>Flux是设计思想，Redux是React中Flux的实现。</p> <p>我们不写代码，但是看几个细节：</p> <p>AppContainer.js：</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/AppContainer.png" alt=""></p> <p>TodoAction.js：</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/TodoAction.png" alt=""></p> <p>TodoStore.js：</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/TodoStore.png" alt=""></p> <h2 id="redux"><a href="#redux" aria-hidden="true" class="header-anchor">#</a> Redux</h2> <h3 id="基本概念-2"><a href="#基本概念-2" aria-hidden="true" class="header-anchor">#</a> 基本概念</h3> <p>官网：http://redux.js.org/</p> <ol><li>Redux就是Flux思想在React中的实现。</li> <li>Redux是一个可以预测状态的 JS app容器。</li></ol> <h3 id="通过例子来学习redux"><a href="#通过例子来学习redux" aria-hidden="true" class="header-anchor">#</a> 通过例子来学习Redux</h3> <p>下载https://github.com/reactjs/redux/</p> <p>然后打开\examples\counter-vanilla：</p> <ol><li>你的App中全部的state都被存储在一个单独的store中，形式是object tree。</li> <li>唯一的更改state的途径就行emit一个action，这个action描述了发什么什么事。</li> <li>为了指定这些actions如何改变state tree，你必须书写简单的、纯净的reducers。</li></ol> <p>所谓的reducers就是形如这样的纯函数，不继承任何东西：</p> <div class="language- extra-class"><pre class="language-text"><code>function reducer(state,action){
	return 新的state;
}
</code></pre></div><p>官方计数器案例上：</p> <div class="language- extra-class"><pre class="language-text"><code>function counter(state = 0, action) {
  switch (action.type) {
  	case 'INCREMENT':
    	return state + 1
  	case 'DECREMENT':
    	return state - 1
  	default:
    	return state
  	}
}
</code></pre></div><ul><li><p>这就是一个reducer ， 是一个纯函数（这个函数不是谁的方法，不继承谁），接受state、action参数，返回新的state表达式。</p></li> <li><p>它描述了一个action如何使当前state改变为下一个state。</p></li> <li><p>state的形式取决于你，它可以是一个基本类型值，可以是一个数组，可以是一个对象。</p></li> <li><p>唯一需要注意的事情就是永远不要去更改当前的state，而是应该返回一个新的state对象。</p></li> <li><p>Action一般都是大写字母，约定。</p></li></ul> <p>创建一个Redux的store，用它来持有app的state。</p> <div class="language- extra-class"><pre class="language-text"><code>let store = Redux.createStore(counter);
</code></pre></div><p>store的API极其简单，就三个，subscribe，dispatch，getState。</p> <div class="language- extra-class"><pre class="language-text"><code>//渲染
function render() {
     valueEl.innerHTML = store.getState().toString()
}

// 注册render
store.subscibe(render)

//渲染
render();

// 加
document.getElementById('increment').onclick = function () {
      store.dispatch({ type: 'INCREMENT' })
};
 
// 减
document.getElementById('decrement').onclick = function () {
      store.dispatch({ type: 'DECREMENT' })
};

document.getElementById('addnumber').onclick = function () {
      var number = Number(document.getElementById(&quot;shuzitxt&quot;).value);
      store.dispatch({ type: 'ADDNUMBER' , number : number })
 };

// 取余
document.getElementById('incrementIfOdd').onclick = function () {
      if (store.getState() % 2 !== 0) {
          store.dispatch({ type: 'INCREMENT' })
      }
};
</code></pre></div><ul><li><p>我们不是直接去修改state，而是指定了一个简单的JSON对象去描述我们想要什么事情发生，这个JSON对象我们称之为action。</p></li> <li><p>然后你写了一个特定的叫做reducer的函数去指定每一个action要如何改变<strong>整个</strong>app的state。</p></li></ul> <p>​	比如下面我们改变这个案例，让state不是一个number简单类型值了，而是一个JSON，此时页面上只用它的m属性，但是n要陪着跑：</p> <div class="language- extra-class"><pre class="language-text"><code>function counter(state, action){
    //设置state的初始值，使用undefined验证法
    if(state == undefined){
        state = { &quot;m&quot; : 6 , &quot;n&quot; : 9};
    }
    switch (action.type) {
        case 'INCREMENT':
            return {&quot;m&quot; : state.m + 1 , &quot;n&quot; : 9}
        case 'DECREMENT':
            return {&quot;m&quot; : state.m - 1 , &quot;n&quot; : 9}
        case 'ADDNUMBER':
            return {&quot;m&quot; : state.m + action.number , &quot;n&quot; : 9}
        default:
            return state
    }
}
</code></pre></div><p>即，使用ES6中的...自动枚举的运算符：</p> <div class="language- extra-class"><pre class="language-text"><code>function counter(state, action){
    //设置state的初始值，使用undefined验证法
    if(state == undefined){
        state = { &quot;m&quot; : 6 , &quot;n&quot; : 9 , &quot;a&quot; : 1 , &quot;b&quot; : 2};
    }
    switch (action.type) {
        case 'INCREMENT':
            return {...state ,&quot;m&quot; : state.m + 1}
        case 'DECREMENT':
            return {&quot;m&quot; : state.m - 1 , &quot;n&quot; : 9}
        case 'ADDNUMBER':
            return {&quot;m&quot; : state.m + action.number , &quot;n&quot; : 9}
        default:
            return state
    }
}
</code></pre></div><p>此时语法可以非常精简。</p> <p>如果你玩儿过Flux，这里有一个重要区别你要注意。</p> <ul><li><p>Redux中没有Dispatcher的概念（Store自己负责Dispatch个action到自己），也不允许有多个Store。（所以Redux擅长制作有强的“全局数据”概念的web应用，比如商城）。</p></li> <li><p>Redux中只有一个唯一的store，使用唯一的recucing function。</p></li> <li><p>随着你的项目增长，此时不要去增加store，而是应该想着切割现在的store为一个个小store。</p></li> <li><p>这点非常像React中仅仅允许使用一个根节点，但是根节点由众多的节点构成。</p></li> <li><p>你可以使用store的subscribe方法，将store订阅了视图，render是一个函数。此时表示当store变化的时候就会执行函数。</p></li> <li><p>通常情况下请使用React配合。</p></li></ul> <h2 id="react-redux"><a href="#react-redux" aria-hidden="true" class="header-anchor">#</a> React-Redux</h2> <h3 id="不使用react-redux遇见的灾难"><a href="#不使用react-redux遇见的灾难" aria-hidden="true" class="header-anchor">#</a> 不使用React-Redux遇见的灾难</h3> <p>刚才我们学习了Redux，已经基本知道Redux怎么玩儿了，大致步骤：</p> <ul><li><p>设置一个reducer，</p></li> <li><p>弄一个store，从Redux.createStore(reducer);</p></li> <li><p>弄一个render函数</p></li> <li><p>注册一下render，store.subscibe(render)</p></li> <li><p>写监听了，此时要记得store.dispatch(action)，不是直接改store。</p></li></ul> <p>此时和React还没有直接产生关系，换句话说在React中没有使用Redux技术。</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/reactredux.png" alt=""></p> <p>我们现在看一下counter这个案例：</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/counter.png" alt=""></p> <p>这个案例纯属霸王硬上弓，就是我们现在通过标签的属性，将store的值，和对store的操作传给了组件！这太二了！</p> <div class="language- extra-class"><pre class="language-text"><code>const render = () =&gt; {ReactDOM.render(
  &lt;Counter 
	  value={store.getState()} 
	  onIncrement={() =&gt; store.dispatch({ type: 'INCREMENT' })} 
	  onDecrement={() =&gt; store.dispatch({ type: 'DECREMENT' })}
  /&gt;,
  rootEl
)};
</code></pre></div><p>​	那次此时灾难是什么？比如一个组件内部要多store有10种操作，你还传10个属性下去啊？再比如，组件内部还有组件要操作store，你还一直往下传啊？</p> <p>​	所以我们使用一个粘合剂，要优雅的把react和redux合并起来，这个包就叫做react-redux。</p> <p>​	react-redux可以让任何组件在任何地方看见store，机理实际上就是昨天学习的context。但是我们用的时候和context无关，人家帮我们写好了。</p> <p>​	此时我们怎么学习react-redux，还是老方法，结合官方文档看官方demo。</p> <p>​	我们要攻克todomvc这个官方demo。</p> <h3 id="结合官方文档看官方demo"><a href="#结合官方文档看官方demo" aria-hidden="true" class="header-anchor">#</a> <strong>结合官方文档看官方demo</strong></h3> <ul><li><p>React-Redux给我们提供了两个东西：Provider组件、connect函数。</p></li> <li><p>Provider组件要求是最大的组件，传入store属性，此时天下无人不识君。</p></li></ul> <p>官方文档：https://github.com/reactjs/react-redux/tree/master/docs</p> <p>index.js：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react'
import { render } from 'react-dom'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import App from './containers/App'
import reducer from './reducers'
import 'todomvc-app-css/index.css'

const store = createStore(reducer)

render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre></div><p>Provider自定义组件：</p> <ul><li><p>这个Provider组件使得它内部的自定义组件可以使用connect()函数。</p></li> <li><p>通常的，你不能在没有Provider父亲或者组件的情况下，使用connect()函数。</p></li></ul> <p>属性store (Redux Store): APP中唯一的那个store</p> <p>App.js：</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { PropTypes } from 'react'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'
import Header from '../components/Header'
import MainSection from '../components/MainSection'
import * as TodoActions from '../actions'

const App = ({ todos , actions }) =&gt; (
  &lt;div&gt;
    {JSON.stringify(todos)}
    &lt;Header addTodo={actions.addTodo} /&gt;
    &lt;MainSection todos={todos} actions={actions} /&gt;
  &lt;/div&gt;
)

App.propTypes = {
  todos: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
}

const mapStateToProps = state =&gt; ({
  todos: state.todos
})

const mapDispatchToProps = dispatch =&gt; ({
    actions: bindActionCreators(TodoActions, dispatch)
})

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App)
</code></pre></div><ul><li><p>将React组件和Redux的store进行连接。</p></li> <li><p>connect提供了一个方便的API能够适应绝大多数工作。</p></li> <li><p>它没有更改你传进来的类，返回会返回一个已经连接好的新类。</p></li></ul> <p>第一个参数：mapStateToPropsp</p> <ul><li><p>如果你传入了第一个参数，此时这个组件将注册Redux的store的更新信息。</p></li> <li><p>这意味着无论任何时候store被更改了，mapStateToProps函数将会被调用。</p></li> <li><p>mapStateToProps 的返回值必须是一个纯JSON！这个JSON将与组件的props融合。也就是说，这个返回的JSON中的key将自动成为组件的props中的成员。</p></li></ul> <p>如果你不想订阅store的更新，此时不要传这个参数就行了，此时用null占一个位置即可。</p> <div class="language- extra-class"><pre class="language-text"><code>export default connect(
  null,
  mapDispatchToProps
)(App)
</code></pre></div><p>第2个参数，mapDispatchToPropsn';</p> <ul><li>如果第往connect函数中传入了第二个参数，且是一个函数，那么这个函数将获得dispatch方法，这可是可以号令action发出的方法啊！可以间接导致stage的改变。</li> <li>返回一个对象如何绑定action creator（返回action的函数，就是action creator）取决于你自己</li> <li>小提示：你可以使用bindActionCreators()方法轻松的将action creator接口和dispatch进行绑定。</li> <li>如果你省略了第二个参数，此时系统还是会将dispatch对象注入到你的组件中，但是不好用，因为你看不见action清单，所以还是需要用bindActionCreators()去处理一下。</li></ul> <h2 id="阶段性回顾"><a href="#阶段性回顾" aria-hidden="true" class="header-anchor">#</a> 阶段性回顾</h2> <p>温故而知新~</p> <h3 id="原生react"><a href="#原生react" aria-hidden="true" class="header-anchor">#</a> 原生React</h3> <p>自定义组件：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;App&gt;&lt;/App&gt;
</code></pre></div><p>React中做自定义组件非常方便：</p> <div class="language- extra-class"><pre class="language-text"><code>class App extends React.Component(){
	constructor(){
		super();

		this.state = {
			&quot;a&quot; : 1
		}
	}
	
	setA(){
		this.setState({&quot;a&quot; : this.state.a + 1});
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;{this.state.a}&lt;/h1&gt;
				&lt;button onClick={(this.setA).bind(this)}&gt;a加1&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre></div><p>组件里面有数据流动三兄弟：state、props、context。</p> <p>state就是组件内部的状态，组件里面用<strong>this.state</strong>得到状态，用this.setState(JSON)设置state。内部的状态。</p> <p>props用来组件之间（父子之间）来传递数据，比如App组件内部使用了另外一个自定义组件My：</p> <div class="language- extra-class"><pre class="language-text"><code>class App extends React.Component(){
	constructor(){
		super();

		this.state = {
			&quot;a&quot; : 1
		}
	}
	
	setA(){
		this.setState({&quot;a&quot; : this.state.a + 1});
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;{this.state.a}&lt;/h1&gt;
				&lt;button onClick={(this.setA).bind(this)}&gt;a加1&lt;/button&gt;

				&lt;My a={a}&gt;&lt;/My&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre></div><p>My.js：</p> <div class="language- extra-class"><pre class="language-text"><code>class My extends React.Component(){
	constructor(props){
		super();
	}
	
	render(){
		return (
			&lt;div&gt;
			 	&lt;h1&gt;{this.props.a}&lt;/h1&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre></div><p>​	<strong>父子嵌套的时候，即儿子想要修改父亲的一个值（也可以理解为传回一个值给父亲）的时候，我们要传一个函数给子组件。就是将能够操作父亲的state.a这个函数setA传给了子组件，让子组件自己去调用。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>class App extends React.Component(){
	constructor(){
		super();

		this.state = {
			&quot;a&quot; : 1
		}
	}
	
	setA(){
		this.setState({&quot;a&quot; : this.state.a + 1});
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;{this.state.a}&lt;/h1&gt;
				&lt;button onClick={(this.setA).bind(this)}&gt;a加1&lt;/button&gt;

				&lt;My a={a} setA={setA}&gt;&lt;/My&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre></div><p>My.js：</p> <div class="language- extra-class"><pre class="language-text"><code>class My extends React.Component(){
	constructor(props){
		super();

	}
	
	render(){
		return (
			&lt;div&gt;
			 	&lt;h1&gt;{this.props.a}&lt;/h1&gt;
			 	&lt;button onClick={this.props.setA}&gt;a加1&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre></div><h3 id="redux-2"><a href="#redux-2" aria-hidden="true" class="header-anchor">#</a> Redux</h3> <p>Flux是一种架构思想，“<strong>MV不好用，我Flux好用</strong>”。数据的单向流动！</p> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/flux02.png" alt=""></p> <p>​	Flux我们是通过学习facebook提供的官方案例Flux_master中的example/todo_mvc来学习的，扒拉了一下，并没有深入学习。但是了解了：</p> <div class="language- extra-class"><pre class="language-text"><code>state：任意形式（it up to you），可以是基本类型值，可以是JSON、数组。
reducer：是一个pure function，形式是(state,action) =&gt; state
action：是一个pure Object，形式是{type:&quot;ACTIONTYPESTRING&quot;,&quot;v&quot;:number,...}
</code></pre></div><p>​	按钮并不是直接去操作Store的state，而是dispatch一个action！</p> <p>​	Redux是Flux思想在React中的体现。我们先学习了一个Redux_master中的counter_vanilla这么一个案例，这个案例和React没有关系，就是裸奔Redux。</p> <p>​	Redux架构直接作用在React上不优雅，需要将全局的Store一个组件一个组件通过属性下传，特别不优雅！甚至官方给出了一个案例counter这个案例。</p> <p>​	所以我们使用React-Redux这个包，来做React和Redux的粘合剂。</p> <p>先讲一个小东西，撒牙缝，膈应人的就是那个bindActionCreator干嘛的。</p> <p>实际上的本质是一个函数与数据的<strong>镜像绑定</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>var shuju = {
	&quot;a&quot; : 123,
	&quot;b&quot; : 2343,
	&quot;c&quot; : 4545,
	&quot;d&quot; : 435435,
	&quot;e&quot; : 234324324
}

function xianshi(number){
	console.log(&quot;值是&quot; + number);
}

function bind(shuju,xianshi){
	var obj = {};
	for(var k in shuju){
		obj[k] = function(){
			xianshi(shuju[k]);
		}
	}

	return obj;
}

var gaojixianshi = bind(shuju,xianshi);

gaojixianshi.d()
</code></pre></div><p>此时在React-Redux中，应该</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {bindActionCreators} from &quot;redux&quot;;
import {connect} from &quot;react-redux&quot;;
import * as actions from &quot;./actions.js&quot;;

class App extends React.Component{
	render(){
		return (
			&lt;div&gt;
				&lt;button onClick={this.props.actions.jianshao}&gt;按我&lt;/button&gt;
				
				{this.props.v}

				&lt;button onClick={this.props.actions.zengjia}&gt;按我&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}

export default connect(
	(state)=&gt;{
		return {
			&quot;v&quot; : state
		}
	},
	(dispatch)=&gt; ({ &quot;actions&quot; : bindActionCreators(actions,dispatch) })
)(App);
</code></pre></div><p>​	这里的actions是一个对象，是一个和外部文件actions有相同key的对象。actions暴露几个action creator此时这个actions对象就有几个key。</p> <p>​	Redux颠覆了组件之间传值的概念！</p> <p>​	调色板、购物车、Todo</p> <h3 id="组件内部state和全局state"><a href="#组件内部state和全局state" aria-hidden="true" class="header-anchor">#</a> <strong>组件内部state和全局state</strong></h3> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/state02.png" alt=""></p> <p>​	父子组件之间，现在很少通过传入一个函数比如setA()，来让子组件控制父组件的值了；也很少涉及子组件将值传回给父组件。因为现在有了全局的state。子组件只需要更改全局的state（通过dispatch个action来更改），父组件就能够检测到这个改变。</p> <p>​	组件内部的state还是有用的，用来做自己的内部的值，一切和全局无关的值都可以做内部的state。一旦值和全局有关，此时想成“是这个组件的返回值”。</p> <h4 id="调色板-2"><a href="#调色板-2" aria-hidden="true" class="header-anchor">#</a> 调色板</h4> <p>​	现在使用jquery可以通过npm来安装，而不是bower或者下载。</p> <p>​	此时jQuery可以和CMD规范比如webpack构建工具完美结合，<strong>jQuery向外export default了自己的jquery函数（$函数）</strong>。</p> <p>​	组件的数据三兄弟：state、context、props不管是谁发生改变，都会引发render()执行，视图会被重绘（被DIFF算法Virtual DOM计算之后，最小量重绘）。但是，构造函数不会重新执行。*<em>所以我们不管基于什么理由，都不需要将全局的状态，用自己组件的state接收。而仅需要用connect链接一下全局store，然后使用this.props.*<em>即可。这样代码又简单，效果又正确</em></em>。</p> <p>​	注意操作DOM必须要在componentDidMount上面进行，构造器运行的时候还没有上树呢！</p> <div class="language- extra-class"><pre class="language-text"><code>componentDidMount(){
	$(this.refs.barWrap).find(&quot;h1&quot;).html(Math.random())
}
</code></pre></div><p>​	涉及全局的值直接通过this.props.action.change()来发送action改变全局的state。自己用的state，不需要告诉全局。</p> <h4 id="购物车"><a href="#购物车" aria-hidden="true" class="header-anchor">#</a> 购物车</h4> <p><img src="https://raw.githubusercontent.com/gangking/myBlog/master/docs/static/img/gouwuche.png" alt=""></p> <p>​	注意一个事情，就是一个类被connect()(CartBar)处理过，此时其他props的改变，不会引发这个render()的更新了。这是正确的。因为connect()表示我现在要读取全局的state。所以引发视图的改变，仅能通过store的改变。</p> <p>​	要会利用map、filter简化reducer的编写。</p> <div class="language- extra-class"><pre class="language-text"><code>if(action.type == &quot;ADD&quot;){
 		return  {
 			...state,
 			&quot;cart&quot; : state.cart.map(function(item,index){
 				return index == action.index ? {...item,&quot;amount&quot; : item.amount + 1} : item;
 			})
 		};
 	}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {connect} from &quot;react-redux&quot;;
import CartBar from &quot;./CartBar.js&quot;;
import * as actions from &quot;./actions.js&quot;;
import {bindActionCreators} from &quot;redux&quot;;

class App extends React.Component{
	constructor(){
		super();	

	}

	getTotal(){
		var sum = 0;
		this.props.cart.forEach(function(item){
			sum += item.price * item.amount;
		});
		return sum;
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;购物车&lt;/h1&gt;
				&lt;p&gt;{JSON.stringify(this.props.cart)}&lt;/p&gt;

				{
					this.props.cart.map((item,index)=&gt;{
	 					return &lt;CartBar key={index} item={item} index={index} actions={this.props.actions} /&gt;
	 				})
				}

				&lt;hr/&gt;
				&lt;p&gt;总价格: {this.getTotal()}&lt;/p&gt;
			&lt;/div&gt;
		)
	}
}

export default connect(
	(state) =&gt; {
		return {
			&quot;cart&quot; : state.cart
		}
	},
	(dispatch) =&gt; {
		return {
			&quot;actions&quot; : bindActionCreators(actions , dispatch)
		}
	}
)(App);
</code></pre></div><p>CartBar.js</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {connect} from &quot;react-redux&quot;;

class CartBar extends React.Component{
	constructor(){
		super();
	}
 
	render(){
		return (
			&lt;div className=&quot;cartBar&quot;&gt;
				&lt;div className=&quot;box&quot;&gt;
					&lt;p&gt;
						{this.props.item.name}
					&lt;/p&gt;
					&lt;p&gt;
						单价：{this.props.item.price}
					&lt;/p&gt;
					&lt;p&gt;
						数量：{this.props.item.amount}
					&lt;/p&gt;
					&lt;p&gt;
						小计：{this.props.item.price * this.props.item.amount}
					&lt;/p&gt;
				&lt;/div&gt;
				&lt;p&gt;
					&lt;input 
						type=&quot;button&quot; 
						value=&quot;-&quot; 
						onClick={(this.props.actions.minus).bind(this,this.props.index)}
						disabled = {this.props.item.amount == 0}
					/&gt;
					&lt;input type=&quot;button&quot; value=&quot;+&quot; onClick={(this.props.actions.add).bind(this,this.props.index)}/&gt;
				&lt;/p&gt;
				&lt;hr/&gt;
			&lt;/div&gt;
		)
	}
}

export default CartBar;
</code></pre></div><h4 id="todo待做事项"><a href="#todo待做事项" aria-hidden="true" class="header-anchor">#</a> Todo待做事项</h4> <p>这是facebook的官方案例，主要有几个新知识点</p> <p>combineReducers() 合并reducer</p> <div class="language- extra-class"><pre class="language-text"><code>const rootReducer = combineReducers({
  todos,   //标准reducer
  another //标准reducer
})
</code></pre></div><p>数组的reduce方法：</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [
	1,2,3,4,5
];

var sum = arr.reduce(function(a = 0 ,item){
	return a + item;
});

console.log(sum);  //15
</code></pre></div><p>item依次成为数组每一项，a成为上一次迭代的返回值。</p> <p>寻找数组中最大值：</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [4,4,5,4,545,234,24,345,234];

var id = arr.reduce((a = 0,item) =&gt; Math.max(a,item) , -1);
console.log(id)
</code></pre></div><h2 id="react组件封装"><a href="#react组件封装" aria-hidden="true" class="header-anchor">#</a> React组件封装</h2> <p>​	React课，非常爱封装组件，不像Angular，Angular喜欢用指令、控制器、服务把一个程序拆分出去，对E级别的组件的热情不是很高。但是React很爱封装组件，毕竟封装组件的过程简单的。</p> <p>​	App、Header、Main、InfoBar、Item。</p> <p>​	学习Redux之后，组件就被分为了两种：<strong>被connect()()加工过的</strong>，<strong>一种没有被加工过的</strong>。</p> <ul><li><p>被connect()()加工过的，将全局state和props融合在了一起，将含dispatch的actions和props融合在了一起。组件可以直接“上达天听”。</p></li> <li><p>没有加工过的组件，只能靠父组件给自己传props，自己是看不见全局state的。</p></li></ul> <p>注意：</p> <p>1）全局的state你在组件内部直接使用即可，没有必要用自己组件的local state再承接一下。</p> <p>正确的示范：</p> <div class="language- extra-class"><pre class="language-text"><code>render(){
{this.props.todos.map((item)=&gt;{
    return &lt;li&gt;{item.content}&lt;/li&gt;
})}
}

connect((state)=&gt;{
return {
     todos : state.todos
}
})()
</code></pre></div><ul><li><p>map()方法：“照葫芦画个新瓢儿”。</p></li> <li><p>filter()方法：“过筛子”，true有这项，false没有这项。</p></li> <li><p>reduce()方法：“叠加积累”</p></li> <li><p>forEach()方法：遍历</p></li></ul> <p>错误的示范：</p> <div class="language- extra-class"><pre class="language-text"><code>constructor(){
this.state = {todos : this.props.todos };
}
</code></pre></div><p>2）如果要用local state，此时这个状态一定是全局无关的。</p> <p>比如Main.js组件中，使用了一个filteredTodos这是一个数组，这个数组如何被筛选？被一个local state控制</p> <div class="language- extra-class"><pre class="language-text"><code>this.state = {filter : &quot;全部显示&quot;}
</code></pre></div><p>​	当这个local state改变了，此时过滤条件就变了，界面也就改变了。</p> <p>3）你可能已经发现了，重复性的、用map生成的组件，一般都不用connect()()处理。</p> <p>购物车中，我们用map函数创建了CartBar组件，此时CartBar就是一个普通React组件，没有用connect函数</p> <div class="language- extra-class"><pre class="language-text"><code>{
	this.props.cart.map((item,index)=&gt;{
	  return &lt;CartBar key={index} item={item} index={index} actions={this.props.actions} /&gt;
	})
}
</code></pre></div><p>在todo中，我们用map函数创建了Item组件，此时Item就是一个普通的React组件。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
	{
		filteredTodos.map((item,index)=&gt;{
		  return &lt;li key={index}&gt;&lt;Item item={item} key={index} actions={this.props.actions} /&gt;&lt;/li&gt;
		})
	}
&lt;/ul&gt;
</code></pre></div><p>4） 如果一个组件用了connect()()处理过，此时这个组件一般不会通过自己的非用connect传入的props改变而影响视图改变。</p> <p>connect()()处理的组件我们只关心它与全局state的关系，全局state如何更新它的视图。</p> <p>这个组件一般不通过父组件给自己传入props。</p> <p><strong>现在一定要区分开：connect()()组件就是看全局的，没有connect的组件就看父亲的</strong>。</p> <p>VUEX和Redux类似，也是数据的单向流动，更简化了Redux的语法。</p> <h2 id="redux中异步的处理"><a href="#redux中异步的处理" aria-hidden="true" class="header-anchor">#</a> Redux中异步的处理</h2> <p>看官方DEMO，也要看API。</p> <p>Redux官方文档特别靠谱，https://github.com/reactjs/redux/tree/master/docs</p> <p>Redux的官方demo特别靠谱！</p> <h3 id="bindactioncreators"><a href="#bindactioncreators" aria-hidden="true" class="header-anchor">#</a> bindActionCreators</h3> <p>先补充几个这几天遇见的API，我们只用了，没有看文档。</p> <div class="language- extra-class"><pre class="language-text"><code>connect(null,(dispatch){
return {
    actions : bindActionCreators(actions , dispatch)
}
})(App)
</code></pre></div><p>https://github.com/reactjs/redux/blob/master/docs/api/bindActionCreators.md</p> <p>​	将一个值是action creators的对象，转换为具有同样键名的对象，但是这个新对象的值是已经被dispatch包裹了的action，这样一来他们将可以直接被调用。</p> <h3 id="combinereducers"><a href="#combinereducers" aria-hidden="true" class="header-anchor">#</a> combineReducers</h3> <p>​	当你的app变得很大、很复杂的时候，你可能需要将reducing函数分开，分开成为一个个独立的函数，每一个函数都是state的独立部分。</p> <h3 id="redux中间件"><a href="#redux中间件" aria-hidden="true" class="header-anchor">#</a> Redux中间件</h3> <p>先看官方API，一会儿结合案例再去理解applyMiddleware(...middleware)</p> <ul><li>中间件被建议用于拓展用户自定义的Redux功能。</li> <li>中间件让你的store的dpispath被包裹起来，从而让程序变得有趣和高效。</li> <li>中间件关键的特质是他们是可以组合的。</li> <li>多个中间件可以被综合在一起使用，这些中间件不需要知道在chain（链条）中它前面、后面人的事情。
中间件最通用的一个功能是提供对异步action的支持，这些都不需要写非常复杂的代码，也不需要第三方库。</li> <li>让你的异步action，变得和同步action一致了。</li> <li>比如，有一个中间件叫做redux-thunk，这个东西让你的action creators变得被dispatch函数控制了。</li> <li>redux-thunk中，action creators都必须注入一个dispatch对象，这个对象现在可以异步被调用。</li></ul> <p>这些函数称为thunks</p> <h3 id="webpack-dev-server"><a href="#webpack-dev-server" aria-hidden="true" class="header-anchor">#</a> webpack-dev-server</h3> <p>​	现在我们编程，在异步上发生了什么调用。我们必须有一个服务器才能发出Ajax。</p> <p>​	webpack-dev-server是一个小型的Node.js Express服务器。是我们搞前端的小服务器，不能用于生产环境，只能用于开发。webpack-dev-server是在webpack基础上，提供了一个小服务器。含有webpack的功能。</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm install --save-dev webpack-dev-server
$ npm install -g webpack-dev-server
</code></pre></div><p>此时用命令：</p> <div class="language- extra-class"><pre class="language-text"><code>$ webpack-dev-server --content-base ./
</code></pre></div><p>就可以开启8080端口</p> <p>但是我们一般这么用：改变webpack.config.js文件，增加一行语句：</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
const webpack = require(&quot;webpack&quot;);
 
module.exports = {
    entry: &quot;./app/app.js&quot;,  
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        publicPath:&quot;/dev/&quot;,
        filename: &quot;all.js&quot;
    },
    module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /(node_modules|bower_components)/ ,
				use: {
					loader: 'babel-loader',
					options: {
				  		presets: ['es2015','react'],
				  		plugins: [&quot;transform-object-rest-spread&quot;]
					}
				}
			}
		]
	},
	watch : true
};
</code></pre></div><p>在package.json文件中：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;name&quot;: &quot;02&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --content-base ./&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.24.1&quot;,
    &quot;babel-loader&quot;: &quot;^6.4.1&quot;,
    &quot;babel-plugin-transform-object-rest-spread&quot;: &quot;^6.23.0&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,
    &quot;jquery&quot;: &quot;^3.2.1&quot;,
    &quot;react&quot;: &quot;^15.5.4&quot;,
    &quot;react-dom&quot;: &quot;^15.5.4&quot;,
    &quot;react-redux&quot;: &quot;^5.0.4&quot;,
    &quot;redux&quot;: &quot;^3.6.0&quot;,
    &quot;redux-logger&quot;: &quot;^3.0.1&quot;,
    &quot;webpack&quot;: &quot;^2.4.1&quot;,
    &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;
  }
}

</code></pre></div><p>此时运行：</p> <div class="language- extra-class"><pre class="language-text"><code>$ npm run start
</code></pre></div><h3 id="redux-thunk"><a href="#redux-thunk" aria-hidden="true" class="header-anchor">#</a> redux-thunk</h3> <p>​	装完webpack-dev-server之后，我们言归正传，我们说自己写一个异步流，你会发现我们无法完成：</p> <div class="language- extra-class"><pre class="language-text"><code>export const add = () =&gt; {
	$.get(&quot;/shu.txt&quot;,function(data){
		return {type : &quot;ADD&quot; , number : data}  //return，触发的内层函数的return
	});
};

</code></pre></div><p>所以必须使用redux-thunk中间件来完成异步流的操作：</p> <p>App.js文件：</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {render} from &quot;react-dom&quot;;
import {Provider} from &quot;react-redux&quot;;
import {createStore , applyMiddleware} from &quot;redux&quot;;
import reducer from &quot;./reducers/index.js&quot;;
import Main from &quot;./components/Main.js&quot;;
+ import thunk from &quot;redux-thunk&quot;;

//任何对state的改变之前都会顺序执行中间件。
+ let store = createStore(reducer,applyMiddleware(thunk));

render(
	&lt;Provider store={store}&gt;
		&lt;div&gt;
			&lt;Main&gt;&lt;/Main&gt;
		&lt;/div&gt;
	&lt;/Provider&gt;
	,
	document.getElementById(&quot;container&quot;)
)
</code></pre></div><p>​	Main.js中，不需要用connect()函数的第二个参数，此时由于我们已经有了中间件，我们的任何一个组件的props中都直接可以使用dispatch函数了。所以<strong>redux-thunk帮助我们让所有的组件的props中存在了dispatch方法，注意这个组件一定要被connect处理。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {connect} from &quot;react-redux&quot;;
import {bindActionCreators} from &quot;redux&quot;;

class Main extends React.Component{
	constructor({a,dispatch}){
		super();

	}

	add(){
		var self = this;
		$.get(&quot;/shu.txt&quot;,function(number){
+			self.props.dispatch({&quot;type&quot; : &quot;ADD&quot; , number : Number(number)});
		});
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;{this.props.a}&lt;/h1&gt;
				&lt;input type=&quot;button&quot; value=&quot;点击我加1&quot; onClick={(this.add).bind(this)}/&gt;
			&lt;/div&gt;
		)
	}
}

+ export default connect(
+ 	(state) =&gt; {
+ 		return {
+ 			&quot;a&quot; : state.todoReducer
+ 		};
+ 	}
+ )(Main);
</code></pre></div><p>写法不好，因为actions.js就没用了，你的actions不能外置为统一的文件</p> <div class="language- extra-class"><pre class="language-text"><code>$.get(&quot;/shu.txt&quot;,function(data){
	var number = Number(data);
	self.props.dispatch({&quot;type&quot; : &quot;ADD&quot; , &quot;number&quot; : number});
});
</code></pre></div><p>平时我们写的Action Creator：</p> <div class="language- extra-class"><pre class="language-text"><code>export const minus = () =&gt; {return {&quot;type&quot; : &quot;MINUS&quot;}};
</code></pre></div><p>现在异步的Action Creator不要直接返回Action，而是返回一个携带dispatch 的函数：</p> <div class="language- extra-class"><pre class="language-text"><code>export const add = () =&gt; (dispatch) =&gt; {
	$.get(&quot;/shu.txt&quot;,function(data){
		var number = Number(data);
+		dispatch({&quot;type&quot; : &quot;ADD&quot; , &quot;number&quot; : number});
	});
}

</code></pre></div><p>​	这个函数相当于“延长”了dispatch持续时间，就是说我要dispatch出一个action，但是立即我发不出，因为参数我需要从Ajax获得。此时返回一个携带dispatch函数的写法，相当于“延长”了dispatch。</p> <div class="language- extra-class"><pre class="language-text"><code>现在我们做一个组件，我们有点和之前不一样：
1） 现在connect中一般不写第二个参数了，就是说省略掉MapDispatchToProps；
2） 在程序开头用import {枚举} from &quot;action.js&quot;  枚举这个组件中可能用到的action；
3） 点击按钮要发送action了，此时不需要考虑它是同步的还是异步的，一律使用一样的语法来发送：
this.props.dispatch(add());
this.props.dispatch(minus())
</code></pre></div><p>​	也就是说，在视图、组件层面，我们丝毫看不见业务的底层实现。actions才能看见谁是同步的，谁是异步的。</p> <div class="language- extra-class"><pre class="language-text"><code>import React from &quot;react&quot;;
import {connect} from &quot;react-redux&quot;;
import {add , minus} from &quot;../actions/actions.js&quot;;

class Main extends React.Component{
	constructor({a,dispatch}){
		super();
	}

	add(){
		this.props.dispatch(add());
	};

	minus(){
		this.props.dispatch(minus());
	}

	render(){
		return (
			&lt;div&gt;
				&lt;h1&gt;{this.props.a}&lt;/h1&gt;
				&lt;button onClick={(this.add).bind(this)}&gt;按我加一个数&lt;/button&gt;
				&lt;button onClick={(this.minus).bind(this)}&gt;按我减1&lt;/button&gt;
			&lt;/div&gt;
		)
	}
}

export default connect(
	(state)=&gt; {
		return {
			a : state
		}
	}
)(Main);
</code></pre></div><p>actions.js:</p> <div class="language- extra-class"><pre class="language-text"><code>export const add = () =&gt; (dispatch) =&gt; {
	$.get(&quot;/shu.txt&quot;,function(data){
		var number = Number(data);
		dispatch({&quot;type&quot; : &quot;ADD&quot; , &quot;number&quot; : number});
	});
}

export const minus = () =&gt; ({&quot;type&quot; : &quot;MINUS&quot; });
</code></pre></div><p>API上的话：</p> <ul><li>Redux Thunk中间件允许你书写一个action creator，这个action creator不需要返回action，而仅需要返回一个函数。</li> <li>thunk这个东西可以延迟dispatch一个action的事件，仅仅当确定参数已经返回了，才发送action。</li> <li>内嵌函数接受两个参数，dispatch、getStateolas;</li></ul> <h2 id="json-server"><a href="#json-server" aria-hidden="true" class="header-anchor">#</a> JSON-server</h2> <p>这是一个虚拟的数据库服务器，可以轻松制作一套假的RESTful API。此时就不需要数据库了。</p> <p>这是前端的小玩意儿，不能真正上线使用。</p> <p>https://github.com/typicode/json-server</p> <div class="language- extra-class"><pre class="language-text"><code>cnpm install -g json-server
</code></pre></div><p>就可以使用json-server命令了。</p> <p>创建一个json文件，database.json</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;students&quot;: [
    {
      &quot;id&quot;: 10001,
      &quot;sex&quot;: &quot;男&quot;,
      &quot;name&quot;: &quot;小明&quot;
    },
    {
      &quot;id&quot;: 10002,
      &quot;name&quot;: &quot;小红&quot;,
      &quot;sex&quot;: &quot;女&quot;
    }
  ],
  &quot;courses&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;语文课&quot;
    }
  ]
}
</code></pre></div><p>然后打开CMD，输入</p> <div class="language- extra-class"><pre class="language-text"><code>$ json-server --watch database.json --port 9000
</code></pre></div><p>表示以database.json文件作为数据库，将RESTful API运行在9000端口。</p> <p>访问：http://127.0.0.1:9000/students</p> <p>这些不用看，easy mock更好用：<a href="https://www.easy-mock.com/login" target="_blank" rel="noopener noreferrer">https://www.easy-mock.com/login<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="react开发模式"><a href="#react开发模式" aria-hidden="true" class="header-anchor">#</a> React开发模式</h2> <p>React玩命的封装组件，组件不仅仅体现在了HTML的复用上、JS的封装上，数据流也非常清晰。父组件掌握的数据多，子组件掌握的数据少。有了Redux配合，所有组件又可以操作全局的state，又可以操作自己的local state。</p> <ul><li><p>React + Redux本质就是负责数据拆分的，<strong>DOM界面被拆分的同时，对数据的操作也被拆分了</strong>。数据的单向流动。</p></li> <li><p>Angular的哲学是HTML大补丁，所以Angular提供了很多ng-repeat、ng-pattern、ng-model等等这种小指令，但是在全局的数据的拆分上，没有体现的。全局的数据在所谓的“服务”中，非常不好用。</p></li> <li><p>Vue吸取了两者的优点，又有指令，又有数据的单向流动。封装性更强。</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>this.props.album		//在connect配合下，得到全局state
this.state.onEdit;    //得到自己的state
</code></pre></div><p>​	所以React中更加注重数据。React中也把一个尴尬的事儿解决了，就是数据和DOM的事儿：</p> <ul><li><p>如果DOM和数组是对应关系，比如数组增加一项，</p></li><li>就多一项，数组改变顺序，li也改变了顺序，此时要用React操作DOM。<p></p></li> <li><p>如果这里的DOM效果和数据没有对应关系，此时用jQuery。</p></li></ul> <p>React + Redux中，jQuery更加灵活。你比如说Angular中封装了AngularDOM对象，</p> <div class="language- extra-class"><pre class="language-text"><code>angular.element($(&quot;#box&quot;)).append();
</code></pre></div><p>React中没有React DOM对象。因为React就是专注于做组件，做数据的单向流动。</p> <h2 id="react路由"><a href="#react路由" aria-hidden="true" class="header-anchor">#</a> React路由</h2> <p>实现React路由可以使用：</p> <p>https://github.com/ui-router/react    		→ ui-router的react版本</p> <p>https://reacttraining.com/react-router/  	→ 官方维护的一个router</p> <h3 id="react-router基本使用"><a href="#react-router基本使用" aria-hidden="true" class="header-anchor">#</a> <strong>React-router基本使用</strong></h3> <div class="language- extra-class"><pre class="language-text"><code>npm install --save react-router-dom
</code></pre></div><p>react-router最大的特点就是路由容器和地址是写在一个组件上的，没有所谓的路由清单。&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import { render } from 'react-dom';
import { BrowserRouter as Router,Route,Link } from 'react-router-dom'
import App from './App.js';

const Home = () =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Home&lt;/h2&gt;
  &lt;/div&gt;
);

const About = () =&gt; (
  &lt;div&gt;
    &lt;h2&gt;About&lt;/h2&gt;
  &lt;/div&gt;
);


render(
	(
		&lt;Router&gt;
		    &lt;div&gt;
				&lt;ul&gt;
					&lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt;
					&lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;
				&lt;/ul&gt;
				&lt;hr/&gt;
				&lt;Route exact path=&quot;/&quot; component={Home}/&gt;
				&lt;Route path=&quot;/about&quot; component={About}/&gt;
			&lt;/div&gt;
	    &lt;/Router&gt;
	)
	,
	document.getElementById(&quot;container&quot;)
);
</code></pre></div><p>路由容器和路由清单合二为一了，Route组件又能够表示这是一个组件的容器，又能表示路由清单。</p> <p>子组件的使用和参数的使用：</p> <div class="language- extra-class"><pre class="language-text"><code>const Topics = ({ match }) =&gt; (
  &lt;div&gt;
   
    &lt;h2&gt;Topics&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/rendering`}&gt;
          rendering
        &lt;/Link&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/components`}&gt;
          Components
        &lt;/Link&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;Link to={`${match.url}/props-v-state`}&gt;
          Props v. State
        &lt;/Link&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;Route path={`${match.url}/:topicId`} component={Topic}/&gt;
    
    &lt;Route exact path={match.url} render={() =&gt; (
      &lt;h3&gt;Please select a topic.&lt;/h3&gt;
    )}/&gt;
  &lt;/div&gt;
)

const Topic = ({ match }) =&gt; (
  &lt;div&gt;
    &lt;h3&gt;识别到的URL参数：{match.params.topicId}&lt;/h3&gt;
  &lt;/div&gt;
)
</code></pre></div><h3 id="react-router路由规划"><a href="#react-router路由规划" aria-hidden="true" class="header-anchor">#</a> React-router路由规划</h3> <div class="language- extra-class"><pre class="language-text"><code>┣ App.js
┣ main.js
┣ yinyue
┣    ┣   Yinyue.js
┣ home
┣    ┣   Home.js
┣ xinwen
┣    ┣   Xinwen.js
┣    ┣   XinwenArticle.js
</code></pre></div><p><strong>main.js：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import { render } from 'react-dom';
import { Route , Link , HashRouter as Router} from 'react-router-dom'
import App from './App.js';

render(
  &lt;Router hashType=&quot;hashbang&quot;&gt;
  	&lt;App&gt;&lt;/App&gt;
  &lt;/Router&gt;,
  document.getElementById(&quot;container&quot;)
);

</code></pre></div><p><strong>App.js：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import Yinyue from &quot;./yinyue/Yinyue.js&quot;;
import Xinwen from &quot;./xinwen/Xinwen.js&quot;;
import Home from &quot;./home/Home.js&quot;;
import { Route , Link } from 'react-router-dom'

export default () =&gt; {
	return (
		&lt;section&gt;
			&lt;header&gt;
				&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;
				&lt;Link to=&quot;/yinyue&quot;&gt;音乐&lt;/Link&gt;
				&lt;Link to=&quot;/xinwen&quot;&gt;新闻&lt;/Link&gt;
			&lt;/header&gt;
			&lt;section className=&quot;main&quot;&gt;
				&lt;Route exact path=&quot;/&quot; component={Home}&gt;&lt;/Route&gt;
				&lt;Route path=&quot;/yinyue&quot; component={Yinyue}&gt;&lt;/Route&gt;
				&lt;Route path=&quot;/xinwen&quot; component={Xinwen}&gt;&lt;/Route&gt;
			&lt;/section&gt;
		&lt;/section&gt;
	);
}
</code></pre></div><p><strong>xinwen/Xinwen.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import { Route , Link , NavLink } from 'react-router-dom';
import XinwenArticle from &quot;./XinwenArticle&quot;;

const data = [
	{ &quot;id&quot; : 1 , &quot;title&quot; : &quot;新闻1&quot; },
	{ &quot;id&quot; : 2 , &quot;title&quot; : &quot;新闻2&quot; },
	{ &quot;id&quot; : 3 , &quot;title&quot; : &quot;新闻3&quot; },
	{ &quot;id&quot; : 4 , &quot;title&quot; : &quot;新闻4&quot; }
];

export default ({match}) =&gt; {
	return (
		&lt;section&gt;
			&lt;h1&gt;我是新闻栏目{JSON.stringify(match)}&lt;/h1&gt;
			{
				data.map((item,index) =&gt; {
					return &lt;NavLink activeClassName=&quot;cur&quot; key={index} to={match.path + &quot;/&quot; + item.id}&gt;{item.title}&lt;/NavLink&gt;
				})
			}
			&lt;Route path={match.path + &quot;/:newsid&quot;} component={XinwenArticle}&gt;&lt;/Route&gt;
		&lt;/section&gt;
	);
}

</code></pre></div><p><strong>/xinwen/XinwenArticle.js：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';

export default ({match}) =&gt; {
	return (
		&lt;h1&gt;我是新闻{JSON.stringify(match.params.newsid)}&lt;/h1&gt;
	)
}
</code></pre></div><h3 id="和redux结合"><a href="#和redux结合" aria-hidden="true" class="header-anchor">#</a> 和Redux结合</h3> <p>React-Router-Redux用于将路由和Redux结合。</p> <p>https://github.com/reactjs/react-router-redux</p> <div class="language- extra-class"><pre class="language-text"><code>import React from 'react';
import { render } from 'react-dom';
import { combineReducers , createStore } from 'redux';
import { Provider } from 'react-redux';
import { Route , Link , HashRouter as Router , browserHistory } from 'react-router-dom'
+ import { routerReducer , syncHistoryWithStore } from 'react-router-redux';
+ import createHistory from 'history/createHashHistory'
import reducer from './reducers/index.js';
import App from './components/App.js';

+ const store = createStore(
+   combineReducers({
+     reducer,
+     routing: routerReducer
+   })
+ );

render(
+ 	&lt;Provider store={store} history={createHistory()}&gt;
	  &lt;Router hashType=&quot;hashbang&quot; &gt;
	  	&lt;App&gt;&lt;/App&gt;
	  &lt;/Router&gt;
	&lt;/Provider&gt;
  ,
  document.getElementById(&quot;container&quot;)
);

</code></pre></div><h3 id="react-router-2"><a href="#react-router-2" aria-hidden="true" class="header-anchor">#</a> React-router 2</h3> <p>阮一峰的博客学习：</p> <p>http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</p> <p>这篇完结~</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/gangking/myBlog/edit/master/docs/react/01.md" target="_blank" rel="noopener noreferrer">编辑文档</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2019-8-9 20:04:32</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myBlog/react/" class="prev router-link-active">
          介绍
        </a></span> <span class="next"><a href="/myBlog/react/02.html">
          React慕课笔记
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.9a205e1a.js" defer></script><script src="/myBlog/assets/js/2.c03f67b8.js" defer></script><script src="/myBlog/assets/js/22.5e365889.js" defer></script>
  </body>
</html>
