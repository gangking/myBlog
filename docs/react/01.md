# React基础（我认为）

## 简介

来自Facebook，2013年诞生。

- **和Angular不同，React并不是一个完整的MVC/MVVM框架，它只专注于提供清晰、直接的View视图层解决方案。**它的功能全部以构建组件视图为核心，并提供类似控制器的函数接口和生命周期函数。在React中没有控制器、没有服务、没有指令、没有过滤器等等。

- **React非常轻**，目标是Minimal API interface（最小化API接口），只提供组件化相关的非常少量的API。**简化了一切可以简化的东西**。比如说Angular中做一个组件，实际上叫做E级别的指令，要写scope、link函数，但是React最大限度的简化了一个组件的开发。事实上React就是为了组件开发而诞生的。

- **React可以搭配Flux等架构（Redux实现）使用。**有Flux架构护航，数据的单向流动，自称是比MVC、MVVM更高级的一种模式。可以开发大型应用的。

- **React使用Virtual DOM技术，**使得它性能卓越，开销很小。



## Virtual DOM

​	Virtual DOM是React中的一个很重要的概念，在日常开发中，前端工程师们需要将后台的数据呈现到界面中，同时要能对用户的操作提供反馈，作用到UI上…… 这些都离不开DOM操作。但是我们知道，**频繁的DOM操作会造成极大的资源浪费，也通常是性能瓶颈的原因。于是React 引入了Virtual DOM。Virtual DOM的核心就是***计算比较改变前后的DOM区别，然后用最少的DOM操作语句对DOM进行操作。

​	比如说要进行这样的DOM转换：

![](../static/img/VirtualDOM01.png)

不用Virtual DOM技术：删除4个li，插入5个li。

使用Virtual DOM技术：通过计算，我们只需要改变4个li的innerHTML，并且插入一个li即可。

 

### DIFF算法

Virtual DOM技术使用了DIFF算法，DIFF算法是一个比较计算层次结构区别的算法，现在主要用来计算DOM之间的差异。

![用DIFF算法可以计算两个JSON结构之间的差别](../static/img/VirtualDOM02.png)

用DIFF算法可以计算两个JSON结构之间的差别。

![](../static/img/VirtualDOM03.png)

现在DIFF算法为Virtual DOM技术服务，用来比较DOM结构的差异：

如果不使用Virtual DOM技术，此时要删除3个节点，插入3个节点。使用Virtual DOM技术仅仅需要移动节点即可。



### JSX语法糖

**React中使用JSX语法糖**，JSX = JavaScript + XML。js文件中写HTML模板，代码语境不需要来回切换的。也就是说，在Angular中模板写在.html文件中。React中使用.js文件来当做HTML模板，语境是统一的，非常清晰简明。jsx语法比``运算符还要简单，是最优雅的将HTML和JS结合的方案。

官网文档：http://reactjs.cn/react/index.html

菜鸟教程的文档不错：http://www.runoob.com/react/react-tutorial.html
中文翻译的手册：http://www.css88.com/react/docs/why-react.html



## React配置和Hello World

### React配置（webpack）

我们创建一个项目文件夹01_HelloWorld，在这个文件夹中，配置webpack + babel环境。让webpack可以指导babel翻译ES6语法。

![](../static/img/VirtualDOM04.png)

#### 基本配置

创建package.json项目身份证：

```
$ npm init -y
```

安装webpack，并且设置为项目依赖：

```
$ npm install --save-dev webpack
```

当然你必须之前已经在-g下安装过webpack。

我们创建一个webpack.config.js文件，这个文件是webpack工作的参考。

我们对着https://webpack.js.org/configuration/  这个文档来创建webpack.config.js文件。

webpack.config.js文件：

```
const path = require('path');
module.exports = {
    entry: "./app/main.js",  
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "all.js"
    }
}
```

至此，我们的webpack就已经可以进行标准的CMD模块化开发了。

#### 引入ES6模块

我们引入babel-loader翻译ES6：

我们参考https://github.com/babel/babel-loader 改变webpack.config.js文件：

```
const path = require('path');
module.exports = {
    entry: "./app/main.js",  
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "all.js"
    },
    module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /(node_modules|bower_components)/ ,
				use: {
					loader: 'babel-loader',
					options: {
				  		presets: ['es2015']
					}
				}
			}
		]
	}
}
```

友情提醒：webpack1和2在配置上差别最大的就是loader的书写方法。module → rules → test/use属性，这是标准webpack2的写法。

安装：

```
$ npm intall --save-dev babel-loader
$ npm intall --save-dev babel-core
$ npm intall --save-dev babel-preset-es2015
```

此时运行

$ webpack

命令，将自动的使用CMD构建app文件夹中main.js文件，并且使用babel翻译。



#### 配置react

```
$ npm install --save-dev react
$ npm install --save-dev react-dom
$ npm install --save-dev babel-preset-react
```

你可能会问：

① react为什么不是bower来安装，而是npm来安装

② 为什么是save-dev而不是save，也就是说为什么是开发依赖，而不是运行依赖。

稍后配置完毕解答。

改变webpack.config.js文件，增加一个babel翻译的配置项presets

```
const path = require('path');

module.exports = {
    entry: "./app/main.js",  
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "all.js"
    },
    module: {
		rules: [
			{
				test: /\.js$/,
				exclude: /(node_modules|bower_components)/ ,
				use: {
					loader: 'babel-loader',
					options: {
				  		presets: ['es2015','react']
					}
				}
			}
		]
	}
}
```

至此我们已经配置完毕react起步的所有的依赖，我们目前的package.json文件：

```
{
  "name": "01",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.24.1",
    "babel-loader": "^6.4.1",
    "babel-preset-es2015": "^6.24.1",
    "babel-preset-react": "^6.24.1",
    "react": "^15.5.4",
    "react-dom": "^15.5.4",
    "webpack": "^2.4.1"
  }
}
```



### Hello World

创建app/App.js文件，这是一个组件：

```
import React , {Component} from "react";
//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends Component{
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return <h1>我是React，很高兴遇见你！说{5000+5000}次我爱你！</h1>;
	}
}
//向外暴露
export default App;
```

下面就要使用这个App组件，所以我们来到/app/main.js文件：

```
import React from "react";
import {render} from "react-dom";
//引入组件
import App from "./App.js";

//使用、挂载组件，两个参数
//第一个参数是jsx语法
//第二个参数表示组件挂在哪里
render(
	<App></App> , 
	document.getElementById("app-container")
);
```



## 简单介绍jsx语法糖

| JSX语法翻译前               | JSX语法翻译后               |
| --------------------------- | --------------------------- |
| ![](../static/img/jsxQ.png) | ![](../static/img/jsxH.png) |

需要注意：

### ① **必须被一个单独的大标签包裹**



比如div或者section

错误的：

```
return <h1>我是React，很高兴遇见你！HAHAHAHA</h1>
<h1>我是React，很高兴遇见你！HAHAHAHA</h1>;
```

正确的：应该被一个div包裹起来，小括号也挺好用的：

```
return (
	<div>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
	</div>
);

```

### ② **标签必须封闭**



错误的：

```
return (
	<div>
		<img src="" >
	</div>
);
```

正确的：

```
return (
	<div>
		<img src="" />
	</div>
);
```

### ③ **class要写成className，for要写成htmlFor**



错误的：

```
return (
	<div>
		<div class="box" ></div>
	</div>
);
```

正确的：

```
return (
	<div>
		<div className="box" ></div>
	</div>
);
```

### ④ HTML注释不能使用，只能使用JS注释。



### ⑤ **原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀**。



错误：

```
return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>
				<p a="10"></p>
			</div>
		);
```

正确：

```
return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>
				<p data-a="10"></p>
			</div>
		);
```

如果是自定义标签，此时可以随便传属性：

```
<App a="123213"></App>
```

### ⑥ **JS表达式用{}单大括号包裹**



在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.

```
<h1>我是React，很高兴遇见你！{1+2}</h1>

{3 > 8 ? "A" : "B"}
```

### ⑦ **可以运行函数**：



```
import React from "react";
//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends React.Component{
	//定义一个函数haha，接受一个参数
	haha(lanmu){
		if(lanmu == "篮球"){
			return (
					<ul>
						<li>乔丹</li>
						<li>科比</li>
						<li>奥尼尔</li>
					</ul>
			)
		}else if(lanmu == "足球"){
			return (
				<ul>
					<li>李铁</li>
					<li>郝海东</li>
					<li>C罗</li>
				</ul>
			)
		}
	}
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>
				<h3>JSX语法很好用哦！</h3>
				{3 > 8 ? "A" : "B"}
				<h3>JSX可以调用函数哦！</h3>
				{this.haha("足球")}
			</div>
		);
	}
}
//向外暴露
export default App;
```

### ⑧ **样式使用双大括号**

```
<h3>JSX可以设置样式哦！</h3>

<div style={{"width":"100px","height":20 + 30 + "px","backgroundColor" : "red"}}></div>

```

### ⑨ **可以使用数组**



数组中如果是JSX语法，数组会被自动展开。所以不需要使用ng-repeat这样的指令展开数组。

```
render(){
		//定义一个数组，定义的JSX项目上要求有key属性，只要是重复的数组项目，都要有不能重复的key属性，这是要求。
		let arr = ["白板","幺鸡","二条","三饼"].map((item,index)=>{
			return <li key={index}>{item}</li>
		});
		//返回一个jsx语法，非常牛逼语法
		return (
			<div>
				<ul>
					{arr}
				</ul>
			</div>
		);
	}
```

生成:

![](../static/img/JSXARR.png)

## React中的数据传递

​	React中跟数据有关系的就三个东西：state、props、context。我们可以叫做数据传递三兄弟。

### 组件自己身上的属性值变化，不会引起视图改变

​	我们可以在组件的类定义里面写constructor构造器，里面定义this.a = 100 。表示给组件的实例绑定一个a属性，值是100。在jsx中使用的时候，直接this.a即可。

```
import React from "react";
class App extends React.Component{
	//构造函数
	constructor(){
		super();  //要求调用super
		this.a = 100;
	}
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			<div>
				{this.a}
			</div>
		);
	}
}
//向外暴露
export default App;
```

补充知识点super:

```
super( ) ——继承
     在class方法中，继承是使用 extends 关键字来实现的。子类 必须 在 constructor( )调用 super( )方法，否则新建实例时会报错。
	报错的原因是：子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。
```

我们增加一个按钮，试着让用户点击按钮之后，a的值变化：

```
import React from "react";
class App extends React.Component{
	//构造函数
	constructor(){
		super();
		this.a = 100;
	}
	add(){
		this.a++;
		console.log(this.a);
	}
	render(){
		return (
			<div>
				<p>{this.a}</p>
				<p>
				<input type="button" value="按我" onClick={(this.add).bind(this)} />
				</p>
			</div>
		);
	}
}
//向外暴露
export default App;
```

通过案例学习了：

① 绑定监听使用onClick、onMousedown、onMouseenter、onBlur，把on后面的字母大写，React会自动识别React事件。

② 绑定监听函数的时候，this上下文是有问题的，所以需要使用bind()方法来设置上下文

③ 绑定监听函数的时候，注意用{}而不是""

错误的：

```
<input type="button" value="按我" **onClick=****"(this.add).bind(this)"** />
```

![](../static/img/state.png)

所以React中，组件自己的属性的变化不会引发视图的变化！！

### 闭包中的值变化，不会引起视图改变

```
import React from "react";
 
class App extends React.Component{
	render(){
		let b = 99;
		return (
			<div>
				<p>{b}</p>
				<p>
					<input type="button" value="按我" onClick={()=>{b++;console.log(b);}} />
				</p>
			</div>
		);
	}
}

//向外暴露
export default App;
闭包中的值变化，也不会引起视图的改变！

```

### 三兄弟之一 ：state

React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。

React 里，**只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）**。

```
import React from "react";
 
class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			a : 100,
 			b : 200,
 			c : 300
 		}
 	}
 	add(){
 			this.setState({a : this.state.a + 1});
 	}
 	render(){
 		return (
 			<div>
 				<h1>我是APP组件</h1>
 				<p>我有状态state</p>
 				<p>a : {this.state.a}</p>
 				<p>b : {this.state.b}</p>
 				<p>c : {this.state.c}</p>
 				<p>
 					<input type="button" value="按我" **onClick={(this.add).bind(this)}**/>
 				</p>
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```



只有更新三兄弟，才会引发Virtual DOM的改变，从而改变DOM。

- 定义state： 在构造函数中使用this.state属性即可

- 使用state ：在JSX中{this.state.a}

- 改变state： this.setState({a : this.state.a + 1});  不能写++，因为state属性值只读

​	state是内部的（所以也叫作local state），**只有组件自己能改变自己的state，别人想改变自己的state，都不可能！**

​	后面要介绍Redux架构，所有组件自己的state越来越少用了，而是变为了Redux中的state，不要混淆。



### 三兄弟之二 ：props

​	就是定义在自定义组件标签上面的值，就是props。当props改变的时候，会引发Virtual DOM的改变，从而引发视图的重绘。react崇尚数据的单向流动，所以设计的时候就是让数据从父组件流向子组件。props在子组件中是只读的，不能修改的。

如果父组件App，想往子组件MyCompo中传值，使用属性：

```
app/App.js：
import React from "react";
import MyCompo from "./MyCompo.js";

class App extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			<div>
 				<MyCompo a="66" b="77" c="88"></MyCompo>
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```

子组件MyCompo中就可以无脑使用this.props来枚举传入的属性：

```
app/MyCompo.js：
import React from "react";

class MyCompo extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			<div>
 				我是MyCompo组件
 				<p>{this.props.a}</p>
 				<p>{this.props.b}</p>
 				<p>{this.props.c}</p>
 			</div>
 		);
 	}
}

//向外暴露
export default MyCompo;
```



如果需要在构造函数中使用这个值，此时系统会将props最为构造函数的第一个参数传入：

```
class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}
 }
```

在子组件中，props是只读的，不能修改props的值。如果要修改，用state来接收。



#### prop-types

props属性可以被验证有效性：

```
$ npm install --save-dev prop-types
 

import React from "react";
import { PropTypes } from "prop-types";

class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}

 	render(){
 		return (
 			<div>
 				我是MyCompo组件
 				<p>{this.props.a}</p>
 				<p>{this.props.b}</p>
 				<p>{this.state.c}</p>
 				<p>
 					<input type="button" value="按我" onClick={()=>{this.setState({c : this.state.c + 1});}}/>
 				</p>
 			</div>
 		);
 	}
}

//定义组件需要传入的参数，这些都是语法规定
//类名.propTypes，值是一个JSON。key就是需要传进来的props属性名，v就是对它的限制
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,  	//a属性是一个字符串，必传
	b : PropTypes.string,  				//b属性是一个字符串，不必传
	c : PropTypes.number.isRequired		//c属性是一个数组，必传
};

//向外暴露
export default MyCompo;
```



**如果非要从下到上传输数据呢？**子组件要把数据返回给父组件，此时只能用奇淫技巧。**就是父组件传一个函数给子组件，子组件通过传参数调用函数将数据返回给父组件的函数，父组件的函数接受实参改变父组件中的state等值。**

父组件App现在想让子组件MyCompo设置App自己的state.d值，此时就需要传入d值，并且传入一个设置d值的函数到子组件：

```
app/App.js：
import React from "react";
import MyCompo from "./MyCompo.js";

class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			d : 16
 		}
 	}

 	setD(number){
 		this.setState({"d" : number});
 	}

 	render(){
 		return (
 			<div>
 				<p>我是App组件，我有一个d状态：{this.state.d}</p>
 				<MyCompo setD={(this.setD).bind(this)} d={this.state.d}></MyCompo>
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```



子组件就要接受父组件传来的d参数和设置D的函数：

```
import React   from "react";
import { PropTypes } from "prop-types";

class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 		 	d : props.d
 		}

 		this.add = () =>{
 			this.setState({"d" : this.state.d + 1});
 			props.setD(this.state.d + 1);
 		}
 	}

 	render(){
 		return (
 			<div>
 				<hr/>
 				我是MyCompo组件
 				<p>d : {this.state.d}</p>
 				<p>
 					<input type="button" value="按我更改d的值" **onClick={this.add}**/>
 				</p>
 			</div>
 		);
 	}
}

//定义组件需要传入的参数
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,
	b : PropTypes.string.isRequired,
	c : PropTypes.number.isRequired
};
 
//向外暴露
export default MyCompo;

```



​	由此可见React是一个特别简单的一个框架，没有Angular或者vue中directive中的scope，@、=、&等等符号。

​	数据的单向传递是React的精髓。

​	如果通过props传递引用类型数据，此时也是不会垫付“数据单向传递”的限制。子组件中对数组、JSON对象的改变，不会引起父组件中哪个数组、JSON对象的改变，可以认为传入了副本。

### 三兄弟之三： context

​	上下文的精髓是可以跨级传递数据，爷爷组件可以直接传递数据到孙子组件。

语法比较晦涩：

```
app/Yeye.js

import React from "react";
import Baba from "./Baba.js";
import PropTypes from "prop-types";

class Yeye extends React.Component{
	constructor(){
		super();
		this.state = {
			a : 100
		}
	}

	render(){
		return (
			<div>
				<h1>爷爷</h1>
				<Baba></Baba>
			</div>
		);
	}

	//得到孩子上下文，实际上这里表示一种设置，返回一个对象，这个对象就是现在这个家族体系共享的上下文。将上下文中的a值变为自己的状态中的a值
	getChildContext(){
		return {
			a : this.state.a
		}
	}
}


//设置child的上下文类型
Yeye.childContextTypes = {
	a : PropTypes.number.isRequired
}

export default Yeye;
```



app/Baba.js文件，没有写什么东西：

```
import React from "react";
import Sunzi from "./Sunzi";
import PropTypes from "prop-types";

class Baba extends React.Component{
	render(){
		return (
			<div>
				<h1>爸爸</h1>
				<Sunzi></Sunzi>
			</div>
		);
	}
}
 
export default Baba;
```



app\Sunzi.js 

React会将上下文当做构造函数的第二个参数传入：

```
import React from "react";
import PropTypes from "prop-types";

class Sunzi extends React.Component{
	constructor(props,context){
		super();
		console.log(context);  //得到上下文
	}

	render(){
		return (
			<div>
				<h1>孙子</h1>
			</div>
		);
	}
}

//设置上下文的类型
Sunzi.contextTypes = {
	a : PropTypes.number
}

export default Sunzi;
```

结论：

① 当祖先元素中更改了上下文的数据，此时所有的子孙元素中的数据都会更改，视图也会更新；

② 反之不成立，可以认为上下文的数据在子孙元素中是只读的。此时又要需要使用奇淫技巧，就是在context中共享一个操作祖先元素的函数，子孙元素通过上下文获得这个函数，从而操作祖先元素的值。

也就是说，state是自治的不涉及传值的事儿；props是单向的，父亲→儿子；context也是单向的，祖先→后代。如果要反向，就要传入一个函数。

app/Yeye.js：

```
import React from "react";
import Baba from "./Baba.js";
import PropTypes from "prop-types";

class Yeye extends React.Component{
	constructor(){
		super();
		this.state = {
			a : 100
		}
	}

	//设置自己的A值，这个函数要进入上下文的“通道”中
	addA(){
		this.setState({a : this.state.a + 1});
	}

	render(){
		return (
			<div>
				<h1>爷爷{this.state.a} /></h1>
				<Baba></Baba>
			</div>
		);
	}
 
	//得到孩子上下文，实际上这里表示一种设置
	getChildContext(){
		return {
			a : this.state.a,
			addA : (this.addA).bind(this)
		}
	}
}

Yeye.childContextTypes = {
	a 		: PropTypes.number.isRequired,
	addA 	: PropTypes.func.isRequired		//func表示函数
}

export default Yeye;
```



app/Sunzi.js

```
import React from "react";
import PropTypes from "prop-types";

class Sunzi extends React.Component{
	constructor(props,context){
		super();
	}

	render(){
		return (
			<div>
				<h1>孙子{this.context.a} <input type="button" value="按我" onClick={this.context.addA}/></h1>
			</div>
		);
	}
}
 
Sunzi.contextTypes = {
	a 		: PropTypes.number,
	addA 	: PropTypes.func
}

export default Sunzi;
```

context很少用，传值基本用props。除非特别深的跨级别传值，可以用context。



## 其他API;

### 无状态组件

当我们现在的组件仅仅是为了呈递一些DOM元素，没有state、props等东西，此时可以不用费劲

class My extends React.Component{}

而是一个暴露简单函数即可：

My.js

```
import React from "react";

export default () => {
	return (
		<div>
			<h1>我是My组件</h1>
		</div>
	)
}
```

此时真的可以用它：

```
import React from "react";
import My from "./My.js";

class App extends React.Component{
 	constructor(){
 		super();
 	}

 	render(){
 		return (
 			<div>
 				<My></My>
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```

### 默认属性

如果没有传入name输入，那么就以“菜鸟”作为属性：

```
constructor(props){
	super();
    this.state = {
         name : props.name || "菜鸟"
        }
}
```



## 组件的生命周期

组件从没有诞生到诞生，到被移除的完整生命周期，都提供了可以触发事件的函数接口，就是生命周期。

组件的生命周期包含三个主要部分：

 

挂载： 组件被插入到DOM中。

更新： 组件被重新渲染，查明DOM是否应该刷新。

移除： 组件从DOM中移除。

 

声明周期函数：

```
	//挂载之前
	componentWillMount(){
		console.log("componentWillMount");
	}

	//在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。
	componentDidMount(){
		console.log("componentDidMount");
	}
 	
 	//当组件做出是否要更新DOM的决定的时候被调用。“门神”，在改变状态的时候可以选择通过或者不通过。
 	shouldComponentUpdate(nextProps , nextState){
 		if(nextState.a > 0.8){
 			return true;
 		}
 		alert("本次没有随机到大于0.8的，更新被阻止");
 		return false;
 	}

 	//在更新发生之前被调用，没有把门的功能
 	componentWillUpdate(){
		console.log("componentWillUpdate");
 	}

 	//在组件移除和销毁之前被调用
 	componentWillUnmount(){	
 		console.log("componentWillUnmount");
 	}
```

## **React中的表单**

​	React没有提供类似Angular中复杂的表单验证功能，**也没有双向数据绑定**！

​	如果非要做一个效果：文本框中输入内容，实时改变h1中的内容此时就要用模拟的方法，监听文本框的事件，然后改变组件的state状态。

```
import React from "react";

class My2 extends React.Component{
	constructor(props){
		super();
	 	this.change = (this.change).bind(this);
	 	this.state = {
	 		"txt" : ""
	 	}
	}
 
	change(event){
		this.setState({"txt" : event.target.value });
	}

	render(){
		return (
			<div>
			 	<input type="text" onInput={this.change} />
			 	<h1>{this.state.txt}</h1>
 			</div>
		)
	}
}


export default My2;
```

## ref DOM钩子

vue也有：

![](../static/img/refDOM.png)


有时候需要操作DOM元素，ref属性表示一个钩子。可以在其他地方使用this.refs来获得这个DOM元素。

## 小例子（初级）

我们硬着头皮上例子，会发现案例感觉react不怎么好用，这是因为它还没有结合Redux，React功力就没有发挥出来。

### 调色板

```
import React from "react";
import Bar from "./components/Bar/Bar.js";
import "./app.less";


class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			r : 110,
 			g : 220,
 			b : 130
 		}

 		//三个Bar的实例
 		this.bars = ["r","g","b"].map((item,index)=>{
 			return <Bar key={index} v={this.state[item]} color={item} setColor={(this.setColor).bind(this)} />;
 		});
 	}

 	//设置函数，可以设置color颜色为value
 	setColor(color,value) {
 		this.setState({[color] : value});
 	}

 	render(){
 		return (
 			<div>
 				<div className="box" style={{"backgroundColor" : `rgb(${this.state.r},${this.state.g},${this.state.b})`}}></div>
 				{this.bars}
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```

Bar.js：

```
import React from "react";
import "./css.less";
import {PropTypes} from "prop-types";

class Bar extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			v : props.v
 		}

 		//绑定this
 		this.change = (this.change).bind(this);
 		this.setColor = props.setColor;
 	}

 	//改变
 	change(event){
 		this.setState({"v" : parseInt(event.target.value)});
 		this.setColor(this.props.color , this.state.v);
 	}

 	render(){
 		return (
 			<div className="Bar_kaola">
 				<div className="bar">
 					{this.props.color} :
 					<input type="range" min="0" max="255" value={this.state.v} onChange={this.change}/>
 					<input type="number" min="0" max="255" value={this.state.v} onChange={this.change}/>
 				</div>
 			</div>
 		)
 	}
}

Bar.propTypes = {
	v 	: PropTypes.number.isRequired,
	color : PropTypes.string.isRequired,
	setColor : PropTypes.func.isRequired
}

//向外暴露
export default Bar;
```

