# React慕课网学习笔记

facebook2013年五月推出

函数式编程

官网：https://reactjs.org/

React Fibar指React16版本

- 比VUE更灵活

- VUE的API丰富

##环境搭建

1. 引入.js文件来使用React(性能低，维护麻烦)

2. 通过脚手架工具来编码（Creacte-react-app）

   

### Creacte-react-app

```
npm i -g create-react-app

create-react-app my-app

cd my-app

npm start

```

### 工程目录简介

- yarn.lock  记录安装地址

- README.md 项目说明

- package.json  命令配置文件（node包文件）

- .gitignore  告诉git不要上传那些文件

- node_modules 存放项目依赖的第三方模块

- public 

  ```
  主页面 index.html
  项目图标 favicon.ico
  manifest.json
  	网页如果当成APP用，可以用来配置快捷方式图标
  ```

- src  项目主文件夹

  ```
  只需要保留两个文件
  index.js 项目主文件
  App.js 主组件
  
  概念：serviceWorker
  PWA 通过写网页来写手机APP应用
  https协议的服务器上 帮助把上次网页存起来，防止断网
  ```



### react中的组件

组件拆分，有利于维护页面

例如：

- 标题： 标题组件

- 搜索框 ：input组件  button组件

只需要维护对应的组件即可。

```
import React from 'react';

class App extends React.Component {

  render() {
    return ( 
      <div>
      hello word 
      </div>
    );
  }
}

export default App;
```

#### ReactDOM

​	将react组件挂载到页面。

```
// jsx语法
ReactDOM.render(<App />, document.getElementById('root'));
```

##JSX语法

1. 不用单引号包裹

2. 可以自定义标签

3. 使用组件必须将组件名标签化

   注意：组件名必须大写字母开头

   

## 案例TodoList功能

###新概念：

​	Fragment(占位符) 可以代替最外层div

```
render(){
    return (
      <Fragment>
        <input />
        <button>提交</button>
        <ul>
          <li>学英语</li>
          <li>linerning React</li>
        </ul>
        todolist
      </Fragment>
    );
  }
```

###数据声明

```
// 构造函数，最先被执行
  constructor(props) {
    super(props);// 调用父类构造函数
    // 组件数据(也叫组建状态)
    this.state = {
      inputValue: '请输入',
      list: []
    }
  }
```

###事件绑定

```
注意:必须绑定this
<input 
    value = {this.state.inputValue}
    onChange = {this.handleInputChange.bind(this)}
/>

上述写法会占用性能，下面写法更佳！
constructor (props) {
  super(props);
  this.handleClick = this.handleClick.bind(this);
}

render () {
   return (
       <div 
          onClick={this.handleClick}>
          {this.props.content}
       </div>
    )
}
```

###数据修改

```
数据只能通过setState来修改：
this.setState({
   inputValue: e.target.value
})
```

注意：用index做key值是不太好的。

全部代码：

```
import React, { Fragment } from 'react';
class TodoList extends React.Component {
  // 构造函数，最先被执行
  constructor(props) {
    super(props);// 调用父类构造函数
    // 组件数据(也叫组建状态)
    this.state = {
      inputValue: '请输入',
      list: ['学习英文','学习React']
    }
  }
  render(){
    return (
      <Fragment>
        <input 
          value = {this.state.inputValue}
          onChange = {this.handleInputChange.bind(this)}
        />
        <button onClick={this.handleBtnClick.bind(this)}>提交</button>
        <ul>
          {
            this.state.list.map((item,index)=>{
              return (
                <li 
                  key={index} onClick={this.handleItemDelete.bind(this,index)}>{item}
                </li>
              )
            })
          }
        </ul>
        todolist
      </Fragment>
    );
  }
  handleInputChange(e){
    console.log(e.target.value);
    this.setState({
      inputValue: e.target.value
    })
  }
  handleBtnClick(e){
    this.setState({
      // list: this.state.list.push(this.state.inputValue),
      list: [...this.state.list, this.state.inputValue], // 展开运算符
      inputValue: '' // 同时清空
    })
  }
  handleItemDelete(index){
    // imuteble的概念：
    // state 不允许我们做任何改变
    const list = [...this.state.list];
    list.splice(index, 1);
    this.setState({
      list: list
    })
    console.log(index)
  }
}
export default TodoList;

```

### 代码优化

TodoItem.js

```
解构赋值的方式获取值和方法：
render () {
    const { content } = this.props;
    return (
       <div 
          onClick={this.handleClick}>
          {content}
       </div>
    )
}

handleClick() {
    const { deleteItem, index } = this.props;
    deleteItem(index);
}
```

TodoList.js

```
这种写法不推荐：
this.setState({
    inputValue: e.target.value
})
推荐下面写法：
const value = e.target.value
this.setState(() => ({
    inputValue: value
}))
注意：必须要用const来接受一下value值（涉及到异步操作）

1、prevState
指this.state数据修改前的值。
所以下面this.state就可以用prevState代替。
// prevState数据修改前的值
this.setState((prevState) => ({
  list: [...prevState.list, prevState.inputValue], // 展开运算符
   inputValue: '' // 同时清空
}))

2、修改handleItemDelete
handleItemDelete(index){
   this.setState((prevState)=>{
     const list = [...prevState.list];
     list.splice(index, 1);
     return {list}
   })
}

3、用index做key值是有可能造成错误的
```



## JSX语法细节

### 注释

```
多行注释：
{/*下面是一个input框*/}

单行注释：
{
    // 下面是一个input框
}

```

###类名样式

```
className='input'
```

### dangerouslySetInnerHTML

​	能识别字符串中的html代码。

```
<li 
    key={index} 
    onClick={this.handleItemDelete.bind(this,index)}>
    dangerouslySetInnerHTML={{__html: item}}
</li>
        
即： 
dangerouslySetInnerHTML={{__html: item}}
```

### htmlFor 

案例：

```
<label htmlFor="insertArea">输入内容</label>
<input 
   id='insertArea'
   className='input'
   value = {this.state.inputValue}
   onChange = {this.handleInputChange.bind(this)}
   placeholder="请输入"
/>

直接用for属性是不允许的，虽然一样有效果。
```



## 组件拆分和组件传值

一个页面的逻辑会复杂，如果拆分为一个个小组件，每个部分逻辑就比较简单了。

###父向子

父组件向子组件通过属性的形式传值

```
<TodoItem content={item}/>
```

子组件通过props获取父组件的传值

```
<div>
   {this.props.content}
</div>
```

### 子向父

父组件将事件传递给子组件

```
<TodoItem
    index={index}
    content={item}
    deleteItem = {this.handleItemDelete.bind(this)}
/>

注意：这里父组件将方法的this指向绑定给自身了。
```

子组件再通过调用父组件方法，将值传回来。

```
handleClick() {
    this.props.deleteItem(this.props.index);
}
```



##原理进阶

命名式开发：大量的dom操作

声明式开发：面向数据编程（react,vue）

- 可以与其他框架共存

- 组件化

  ```
  class继承React.Component
  组件名首字母大写
  父子传值
  ```

- 单向数据流

  ```
  父组件可以向子组件传内容；
  但是子组件只能使用这个值，不能改变这个值；
  目的：开发方便，避免遇坑
  ```

- 视图层框架

  ```
  父子组件通过属性传值
  1、组件传给非父子组件，对于大型项目很崩溃；
  2、所以要引入数据层框架来处理辅助传值；
  3、因此react专注于视图层；
  ```

- 函数式编程

  ```
  维护方便；
  自动化测试方便；
  ```



## React调试工具安装及使用

在谷歌浏览器商店下载，需要翻墙哦~

搜：Reactdevelopertools

- 知乎是用React开发的，线上版本代码对应为黑色线上代码会压缩，精简一些）
- 本地为红色



##动画

##Redux

##Redux进阶



