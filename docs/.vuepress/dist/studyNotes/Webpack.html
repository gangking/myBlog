<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>webpack | MrXiong</title>
    <meta name="description" content="熊刚的个人博客首页，熊刚的技术作品，熊刚的生活成长">
    <link rel="icon" href="/myBlog/favicon.ico">
  <link rel="manifest" href="/myBlog/manifest.json">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.64f3a7d3.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.bc1e53b8.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.e7431746.js" as="script"><link rel="preload" href="/myBlog/assets/js/7.75128492.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.d1ffd59e.js"><link rel="prefetch" href="/myBlog/assets/js/11.137a1143.js"><link rel="prefetch" href="/myBlog/assets/js/12.82eeeb32.js"><link rel="prefetch" href="/myBlog/assets/js/13.40bde01c.js"><link rel="prefetch" href="/myBlog/assets/js/14.78ec9f2f.js"><link rel="prefetch" href="/myBlog/assets/js/15.acab2bd3.js"><link rel="prefetch" href="/myBlog/assets/js/3.23d65cf4.js"><link rel="prefetch" href="/myBlog/assets/js/4.30143bcb.js"><link rel="prefetch" href="/myBlog/assets/js/5.5b903baa.js"><link rel="prefetch" href="/myBlog/assets/js/6.59ed0b7b.js"><link rel="prefetch" href="/myBlog/assets/js/8.eb099a77.js"><link rel="prefetch" href="/myBlog/assets/js/9.591f278c.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.64f3a7d3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">MrXiong</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">社交媒体</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/social/weixin/" class="nav-link">微信</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/studyNotes/" class="nav-link router-link-active">前端技术</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">社交媒体</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/social/weixin/" class="nav-link">微信</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/studyNotes/" class="nav-link router-link-active">前端技术</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端开发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/studyNotes/" class="sidebar-link">介绍</a></li><li><a href="/myBlog/studyNotes/Webpack.html" class="active sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#基本的概念" class="sidebar-link">基本的概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#mode-开发模式" class="sidebar-link">mode 开发模式</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#入口文件-entry" class="sidebar-link">入口文件(entry)</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#输出-output" class="sidebar-link">输出(output)</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#loader" class="sidebar-link">loader</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#插件-plugins" class="sidebar-link">插件(plugins</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#webpack-的安装" class="sidebar-link">webpack 的安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#本地安装-webpack" class="sidebar-link">本地安装 webpack</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#全局安装-webpack（不推荐" class="sidebar-link">全局安装 webpack（不推荐)</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#快速入门完整-demo" class="sidebar-link">快速入门完整 demo</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#加载非-js-文件" class="sidebar-link">加载非 js 文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#加载-css-文件" class="sidebar-link">加载 CSS 文件</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#module-配置补充" class="sidebar-link">module 配置补充</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#加载-sass-文件" class="sidebar-link">加载 Sass 文件</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#创建-source-map" class="sidebar-link">创建 Source Map</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#postcss-处理-loader（附带：添加-css3-前缀）" class="sidebar-link">PostCSS 处理 loader（附带：添加 css3 前缀）</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#样式表抽离成专门的单独文件并且设置版本号" class="sidebar-link">样式表抽离成专门的单独文件并且设置版本号</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#压缩-css" class="sidebar-link">压缩 CSS</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#js-压缩" class="sidebar-link">JS 压缩</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#解决-css-文件或者-js-文件名字哈希变化的问题" class="sidebar-link">解决 CSS 文件或者 JS 文件名字哈希变化的问题</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#清理-dist-目录" class="sidebar-link">清理 dist 目录</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#加载图片与图片优化" class="sidebar-link">加载图片与图片优化</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#更进一步处理图片成-base64" class="sidebar-link">更进一步处理图片成 base64</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#字体的处理（同图片）" class="sidebar-link">字体的处理（同图片）</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#开发相关辅助" class="sidebar-link">开发相关辅助</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#合并两个webpack的js配置文件" class="sidebar-link">合并两个webpack的js配置文件</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#js-使用-source-map" class="sidebar-link">js 使用 source map</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#监控文件变化，自动编译。使用观察模式" class="sidebar-link">监控文件变化，自动编译。使用观察模式</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#使用-webpack-dev-server-和热更新" class="sidebar-link">使用 webpack-dev-server 和热更新</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#js启用babel转码" class="sidebar-link">JS启用babel转码</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#babel优化" class="sidebar-link">Babel优化</a></li><li class="sidebar-sub-header"><a href="/myBlog/studyNotes/Webpack.html#eslint校验代码格式规范" class="sidebar-link">ESLint校验代码格式规范</a></li></ul></li></ul></li><li><a href="/myBlog/studyNotes/React.html" class="sidebar-link">React</a></li><li><a href="/myBlog/studyNotes/Vue.html" class="sidebar-link">Vue</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="webpack"><a href="#webpack" aria-hidden="true" class="header-anchor">#</a> webpack</h1> <p>源码：<a href="https://github.com/gangking/webpack" target="_blank" rel="noopener noreferrer">https://github.com/gangking/webpack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="webpack-是什么？"><a href="#webpack-是什么？" aria-hidden="true" class="header-anchor">#</a> webpack 是什么？</h3> <p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p> <p><img src="/myBlog/assets/img/webpack.230eb567.png" alt=""></p> <h2 id="基本的概念"><a href="#基本的概念" aria-hidden="true" class="header-anchor">#</a> 基本的概念</h2> <h3 id="mode-开发模式"><a href="#mode-开发模式" aria-hidden="true" class="header-anchor">#</a> mode 开发模式</h3> <p>webpack 提供 mode 配置选项，配置 webpack 相应模式的内置优化。</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.production.config.js
module.exports = {
+  mode: 'production',// 产品模式
}
</code></pre></div><h3 id="入口文件-entry"><a href="#入口文件-entry" aria-hidden="true" class="header-anchor">#</a> 入口文件(entry)</h3> <p>入口文件，类似于其他语言的起始文件。比如：c 语言的 main 函数所在的文件。</p> <p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p> <p>可以在 webpack 的配置文件中配置入口，配置节点为： <code>entry</code>,当然可以配置一个入口，也可以配置多个。</p> <h3 id="输出-output"><a href="#输出-output" aria-hidden="true" class="header-anchor">#</a> 输出(output)</h3> <p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
</code></pre></div><h3 id="loader"><a href="#loader" aria-hidden="true" class="header-anchor">#</a> loader</h3> <p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p> <h3 id="插件-plugins"><a href="#插件-plugins" aria-hidden="true" class="header-anchor">#</a> 插件(plugins</h3> <p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p> <h2 id="webpack-的安装"><a href="#webpack-的安装" aria-hidden="true" class="header-anchor">#</a> webpack 的安装</h2> <p>请确保安装了 <code>Node.js</code> 的最新版本。而且已经在您的项目根目录下已经初始化好了最基本的<code>package.json</code>文件</p> <h3 id="本地安装-webpack"><a href="#本地安装-webpack" aria-hidden="true" class="header-anchor">#</a> 本地安装 webpack</h3> <div class="language- extra-class"><pre class="language-text"><code>$ npm install --save-dev webpack

# 如果你使用 webpack 4+ 版本，你还需要安装 CLI。
npm install --save-dev webpack-cli
</code></pre></div><p>安装完成后，可以添加<code>npm</code>的<code>script</code>脚本</p> <div class="language- extra-class"><pre class="language-text"><code>// package.json
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack --config webpack.config.js&quot;
}
</code></pre></div><h3 id="全局安装-webpack（不推荐"><a href="#全局安装-webpack（不推荐" aria-hidden="true" class="header-anchor">#</a> 全局安装 webpack（不推荐)</h3> <p>将使 webpack 在全局环境下可用：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --global webpack
</code></pre></div><blockquote><p>注意：不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。</p></blockquote> <h2 id="快速入门完整-demo"><a href="#快速入门完整-demo" aria-hidden="true" class="header-anchor">#</a> 快速入门完整 demo</h2> <ul><li>第一步：创建项目结构</li></ul> <p>首先我们创建一个目录，初始化 npm，然后 在本地安装 webpack，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）：</p> <div class="language- extra-class"><pre class="language-text"><code>mkdir webpack-demo &amp;&amp; cd webpack-demo
npm init -y
npm install webpack webpack-cli --save-dev
</code></pre></div><p>项目结构</p> <div class="language- extra-class"><pre class="language-text"><code>  webpack-demo
+ |- package.json
+ |- /dist
+   |- index.html
+ |- /src
+   |- index.js
</code></pre></div><ul><li>第二步：安装 loadash 依赖和编写 js 文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install --save lodash
</code></pre></div><p>编写：src/index.js 文件</p> <div class="language- extra-class"><pre class="language-text"><code>import _ from 'lodash';

function createDomElement() {
  var dom = document.createElement('div');
  dom.innerHTML = _.join(['aicoder', '.com', ' wow'], '');
  return dom;
}

document.body.appendChild(createDomElement());
</code></pre></div><p>index.html</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;起步&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><ul><li>第三步：编写 webpack 配置文件</li></ul> <p>根目录下添加 <code>webpack.config.js</code>文件。</p> <div class="language- extra-class"><pre class="language-text"><code>  webpack-demo
  |- package.json
+ |- webpack.config.js
  |- /dist
    |- index.html
  |- /src
    |- index.js
</code></pre></div><p>webpack.config.js 内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, './dist')
  }
};
</code></pre></div><ul><li>执行构建任务</li></ul> <p>直接执行构建任务：</p> <div class="language- extra-class"><pre class="language-text"><code>npx webpack
</code></pre></div><p>打开： dist/index.html 可以查看到页面的结果。</p> <h2 id="加载非-js-文件"><a href="#加载非-js-文件" aria-hidden="true" class="header-anchor">#</a> 加载非 js 文件</h2> <p>webpack 最出色的功能之一就是，除了 JavaScript，还可以通过 loader 引入任何其他类型的文件</p> <h3 id="加载-css-文件"><a href="#加载-css-文件" aria-hidden="true" class="header-anchor">#</a> 加载 CSS 文件</h3> <ul><li>第一步： 安装 css 和 style 模块解析的依赖 <code>style-loader</code> 和 <code>css-loader</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev style-loader css-loader
</code></pre></div><ul><li>第二步： 添加 css 解析的 loader</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
};
</code></pre></div><ul><li><code>css-loader</code>： 辅助解析 js 中的 <code>import './main.css'</code></li> <li><code>style-loader</code>: 把 js 中引入的 css 内容 注入到 html 标签中，并添加 style 标签.依赖 <code>css-loader</code></li></ul> <blockquote><p>你可以在依赖于此样式的 js 文件中 导入样式文件，比如：import './style.css'。现在，当该 js 模块运行时，含有 CSS 字符串的 <code>&lt;style&gt;</code> 标签，将被插入到 html 文件的 <code>&lt;head&gt;</code>中。</p></blockquote> <ul><li>第三步： 编写 css 文件和修改 js 文件</li></ul> <p>在 src 目录中添加 <code>style.css</code>文件</p> <div class="language- extra-class"><pre class="language-text"><code> webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
+   |- style.css
    |- index.js
  |- /node_modules
</code></pre></div><p>src/style.css</p> <div class="language- extra-class"><pre class="language-text"><code>.hello {
  color: red;
}
</code></pre></div><p>修改 js 文件</p> <div class="language- extra-class"><pre class="language-text"><code>  import _ from 'lodash';
+ import './style.css';

  function createDomElement() {
    let dom = document.createElement('div');
    dom.innerHTML = _.join(['aicoder', '.com', ' wow'], '');
+   dom.className = 'hello';
    return dom;
  }

  document.body.appendChild(createDomElement());
</code></pre></div><p>最后重新打开 dist 目录下的 index.html 看一下文字是否变成了红色的了。</p> <h3 id="module-配置补充"><a href="#module-配置补充" aria-hidden="true" class="header-anchor">#</a> module 配置补充</h3> <p>模块(module): 这些选项决定了如何处理项目中的不同类型的模块。</p> <p>webpack 模块可以支持如下:</p> <ul><li>ES2015 import 语句</li> <li>CommonJS require() 语句</li> <li>AMD define 和 require 语句</li> <li>css/sass/less 文件中的 @import 语句。</li> <li>样式<code>(url(...))</code>或 HTML 文件<code>(&lt;img src=...&gt;)</code>中的图片链接<code>(image url)</code></li></ul> <h4 id="module-noparse"><a href="#module-noparse" aria-hidden="true" class="header-anchor">#</a> module.noParse</h4> <p>值的类型： RegExp | [RegExp] | function</p> <p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  mode: 'devleopment',
  entry: './src/index.js',
  ...
  module: {
    noParse: /jquery|lodash/,
    // 从 webpack 3.0.0 开始,可以使用函数，如下所示
    // noParse: function(content) {
    //   return /jquery|lodash/.test(content);
    // }
  }
  ...
};
</code></pre></div><h4 id="module-rules"><a href="#module-rules" aria-hidden="true" class="header-anchor">#</a> module.rules</h4> <p>创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</p> <p>创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  ...
  module: {
    noParse: /jquery|lodash/,
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
  ...
};
</code></pre></div><h4 id="module-rule"><a href="#module-rule" aria-hidden="true" class="header-anchor">#</a> module Rule</h4> <p>Rule 条件详解</p> <ul><li>字符串：匹配输入必须以提供的字符串开始。是的。目录绝对路径或文件绝对路径。</li> <li>正则表达式：test 输入值。</li> <li>函数：调用输入的函数，必须返回一个真值(truthy value)以匹配。</li> <li>条件数组：至少一个匹配条件。</li> <li>对象：匹配所有属性。每个属性都有一个定义行为。</li></ul> <h4 id="rule-test"><a href="#rule-test" aria-hidden="true" class="header-anchor">#</a> Rule.test</h4> <ul><li>{ test: Condition }：匹配特定条件。一般是提供一个正则表达式或正则表达式的数组，但这不是强制的。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
  ...
};
</code></pre></div><p>其他的条件比如：</p> <ul><li><code>{ include: Condition }</code>:匹配特定条件。一般是提供一个字符串或者字符串数组，但这不是强制的。</li> <li><code>{ exclude: Condition }</code>:排除特定条件。一般是提供一个字符串或字符串数组，但这不是强制的。</li> <li><code>{ and: [Condition] }</code>:必须匹配数组中的所有条件</li> <li><code>{ or: [Condition] }</code>:匹配数组中任何一个条件</li> <li><code>{ not: [Condition] }</code>:必须排除这个条件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.css$/,
        include: [
          path.resolve(__dirname, &quot;app/styles&quot;),
          path.resolve(__dirname, &quot;vendor/styles&quot;)
        ],
        use: ['style-loader', 'css-loader']
      }
    ]
  }
  ...
};
</code></pre></div><h4 id="rule-use"><a href="#rule-use" aria-hidden="true" class="header-anchor">#</a> Rule.use</h4> <p>应用于模块指定使用一个 loader。</p> <p>Loaders can be chained by passing multiple loaders, which will be applied from right to left (last to first configured).</p> <p>加载器可以链式传递，从右向左进行应用到模块上。</p> <div class="language- extra-class"><pre class="language-text"><code>use: [
  'style-loader',
  {
    loader: 'css-loader'
  },
  {
    loader: 'less-loader',
    options: {
      noIeCompat: true
    }
  }
];
</code></pre></div><blockquote><p>传递字符串（如：use: [ &quot;style-loader&quot; ]）是 loader 属性的简写方式（如：use: [ { loader: &quot;style-loader &quot;} ]）。</p></blockquote> <h3 id="加载-sass-文件"><a href="#加载-sass-文件" aria-hidden="true" class="header-anchor">#</a> 加载 Sass 文件</h3> <p>加载 Sass 需要<code>sass-loader</code>。</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm install sass-loader node-sass webpack --save-dev
</code></pre></div><p>使用：</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  ...
  module: {
    rules: [{
      test: /\.scss$/,
      use: [{
        loader: &quot;style-loader&quot;
      }, {
        loader: &quot;css-loader&quot;
      }, {
        loader: &quot;sass-loader&quot;
      }]
    }]
  }
};

// a.scss
$bgColor: pink;
.box{
    background-color: $bgColor;
    font-size: 30px;
}
.test{
    span {
        color: greenyellow;
    }
}

// index.js
import _ from 'lodash';
import './style.css';
+ import './a.scss';

function createDomElement() {
  var dom = document.createElement('div');
  dom.innerHTML = _.join(['aicoder', '.com', ' wow'], '');
//   dom.className = 'hello';
 +  dom.classList.add('box');
  return dom;
}

document.body.appendChild(createDomElement());
</code></pre></div><p>为 sass 文件注入内容：</p> <p>如果你要将 Sass 代码放在实际的入口文件(entry file)之前，可以设置 data 选项。此时 sass-loader 不会覆盖 data 选项，只会将它拼接在入口文件的内容之前。</p> <div class="language- extra-class"><pre class="language-text"><code>{
    loader: &quot;sass-loader&quot;,
    options: {
        data: &quot;$env: &quot; + process.env.NODE_ENV + &quot;;&quot;
    }
}
</code></pre></div><blockquote><p>注意：由于代码注入, 会破坏整个入口文件的 source map。 通常一个简单的解决方案是，多个 Sass 文件入口。</p></blockquote> <h3 id="创建-source-map"><a href="#创建-source-map" aria-hidden="true" class="header-anchor">#</a> 创建 Source Map</h3> <p>在调试中显示scss文件及行数</p> <p><code>css-loader</code>和<code>sass-loader</code>都可以通过该 options 设置启用 sourcemap。</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  ...
  module: {
    rules: [{
      test: /\.scss$/,
      use: [{
        loader: &quot;style-loader&quot;
      }, {
        loader: &quot;css-loader&quot;,
        options: {
          sourceMap: true
        }
      }, {
        loader: &quot;sass-loader&quot;,
        options: {
          sourceMap: true
        }
      }]
    }]
  }
};Copy to clipboardErrorCopied
</code></pre></div><h3 id="postcss-处理-loader（附带：添加-css3-前缀）"><a href="#postcss-处理-loader（附带：添加-css3-前缀）" aria-hidden="true" class="header-anchor">#</a> PostCSS 处理 loader（附带：添加 css3 前缀）</h3> <p><a href="https://postcss.org/" target="_blank" rel="noopener noreferrer">PostCSS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是一个 CSS 的预处理工具，可以帮助我们：给 CSS3 的属性添加前缀，样式格式校验（stylelint），提前使用 css 的新特性比如：表格布局，更重要的是可以实现 CSS 的模块化，防止 CSS 样式冲突。</p> <p>我们常用的就是使用 PostCSS 进行添加前缀，以此为例：</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D postcss-loader
npm install autoprefixer --save-dev

# 以下可以不用安装
# cssnext可以让你写CSS4的语言，并能配合autoprefixer进行浏览器兼容的不全，而且还支持嵌套语法
$ npm install postcss-cssnext --save-dev

# 类似scss的语法，实际上如果只是想用嵌套的话有cssnext就够了
$ npm install precss --save-dev

# 在@import css文件的时候让webpack监听并编译
$ npm install postcss-import --save-dev
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, './dist')
  },
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              sourceMap: true
            }
          },
          {
            loader: 'postcss-loader',
            options: {
              ident: 'postcss',
              sourceMap: true,
              plugins: loader =&gt; [
                require('autoprefixer')({ browsers: ['&gt; 0.15% in CN'] }) // 添加前缀
              ]
            }
          },
          {
            loader: 'sass-loader',
            options: {
              sourceMap: true
            }
          }
        ]
      }
    ]
  }
};
</code></pre></div><h3 id="样式表抽离成专门的单独文件并且设置版本号"><a href="#样式表抽离成专门的单独文件并且设置版本号" aria-hidden="true" class="header-anchor">#</a> 样式表抽离成专门的单独文件并且设置版本号</h3> <p>首先以下的 css 的处理我们都把 mode 设置为 <code>production</code>。</p> <p>webpack4 开始使用： <code>mini-css-extract-plugin</code>插件, 1-3 的版本可以用： <code>extract-text-webpack-plugin</code></p> <blockquote><p>抽取了样式，就不能再用 <code>style-loader</code>注入到 html 中了。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev mini-css-extract-plugin
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// webpack.product.config.js
// 部署模式

// 最终部署模式文件
// 单独抽取css
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, './dist')
    },
    module: {
        rules: [{
            test: /\.(sa|sc|c)ss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                    loader: &quot;css-loader&quot;,
                    options: {
                        sourceMap: true
                    }
                },
                {
                    loader: 'postcss-loader',
                    options: {
                        ident: 'postcss',
                        sourceMap: true,
                        plugins: loader =&gt; [
                            require('autoprefixer')({
                                browsers: ['&gt; 0.15% in CN'] // 浏览器范围，包含ie8
                            }) // 添加前缀
                        ]
                    }
                },
                {
                    loader: &quot;sass-loader&quot;,
                    options: {
                        sourceMap: true
                    }
                }
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].[hash].css', // 设置最终输出的文件名
            chunkFilename: '[id].css'
        })
    ]
};
</code></pre></div><p>再次运行打包：</p> <p>npx webpack -h 查看帮助文档</p> <p>npx webpack --config webpack.product.config.js</p> <p>在 dist 目录中已经把 css 抽取到单独的一个 css 文件中了。修改 html，引入此 css 就能看到结果了。</p> <h3 id="压缩-css"><a href="#压缩-css" aria-hidden="true" class="header-anchor">#</a> 压缩 CSS</h3> <p>webpack5 貌似会内置 css 的压缩，webpack4 可以自己设置一个插件即可。</p> <p>压缩 css 插件：<code>optimize-css-assets-webpack-plugin</code></p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D optimize-css-assets-webpack-plugin
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const autoprefixer = require('autoprefixer');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: 'main.[hash].js',
    path: path.resolve(__dirname, './dist')
  },
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader'
          },
          {
            loader: 'postcss-loader',
            options: {
              ident: 'postcss',
              plugins: loader =&gt; [autoprefixer({ browsers: ['&gt; 0.15% in CN'] })]
            }
          },
          {
            loader: 'sass-loader'
          }
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name][hash].css',
      chunkFilename: '[id][hash].css'
    })
  ],
  optimization: {
    minimizer: [new OptimizeCSSAssetsPlugin({})]
  }
};
</code></pre></div><h3 id="js-压缩"><a href="#js-压缩" aria-hidden="true" class="header-anchor">#</a> JS 压缩</h3> <p>压缩需要一个插件： <code>uglifyjs-webpack-plugin</code>, 此插件需要一个前提就是：<code>mode: 'production'</code>.</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D uglifyjs-webpack-plugin
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const autoprefixer = require('autoprefixer');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: 'main.[hash].js', // 重点！！！！
    path: path.resolve(__dirname, './dist')
  },
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader'
          },
          {
            loader: 'postcss-loader',
            options: {
              ident: 'postcss',
              plugins: loader =&gt; [autoprefixer({ browsers: ['&gt; 0.15% in CN'] })]
            }
          },
          {
            loader: 'sass-loader'
          }
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name][hash].css', // 重点
      chunkFilename: '[id][hash].css'
    })
  ],
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        cache: true,
        parallel: true,
        sourceMap: true // set to true if you want JS source maps
      }),
      new OptimizeCSSAssetsPlugin({}) //压缩css
    ]
  }
};
</code></pre></div><h3 id="解决-css-文件或者-js-文件名字哈希变化的问题"><a href="#解决-css-文件或者-js-文件名字哈希变化的问题" aria-hidden="true" class="header-anchor">#</a> 解决 CSS 文件或者 JS 文件名字哈希变化的问题</h3> <p><code>HtmlWebpackPlugin</code>插件，可以把打包后的 CSS 或者 JS 文件引用直接注入到 HTML 模板中，这样就不用每次手动修改文件引用了。</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev html-webpack-plugin
const path = require('path');
+ const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const autoprefixer = require('autoprefixer');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: 'main.[hash].js',
    path: path.resolve(__dirname, './dist')
  },
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader'
          },
          {
            loader: 'postcss-loader',
            options: {
              ident: 'postcss',
              plugins: loader =&gt; [autoprefixer({ browsers: ['&gt; 0.15% in CN'] })]
            }
          },
          {
            loader: 'sass-loader'
          }
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name][hash].css',
      chunkFilename: '[id][hash].css'
    }),
 +   new HtmlWebpackPlugin({
 +     title: 'AICODER 全栈线下实习', // 默认值：Webpack App
 +     filename: 'main.html', // 默认值： 'index.html'
 +    template: path.resolve(__dirname, 'src/main.html'), // 注意是src下面的
 +     minify: {
 +       collapseWhitespace: true, // 是否移除空行
 +       removeComments: true, // 是否去掉注释
 +       removeAttributeQuotes: true // 移除属性的引号
 +     }
 +   })
  ],
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        cache: true,
        parallel: true,
        sourceMap: true // set to true if you want JS source maps
      }),
      new OptimizeCSSAssetsPlugin({})
    ]
  }
};
</code></pre></div><h3 id="清理-dist-目录"><a href="#清理-dist-目录" aria-hidden="true" class="header-anchor">#</a> 清理 dist 目录</h3> <p>每次构建，我们的 <code>/dist</code> 文件夹都会保存生成的文件，然后就会非常杂乱。</p> <p>通常，在每次构建前清理 <code>/dist</code> 文件夹，是比较推荐的做法</p> <p><code>clean-webpack-plugin</code> 是一个比较普及的管理插件，让我们安装和配置下。</p> <div class="language- extra-class"><pre class="language-text"><code>npm install clean-webpack-plugin --save-dev
</code></pre></div><p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');
  ....
+ const CleanWebpackPlugin = require('clean-webpack-plugin');

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js'
    },
    plugins: [
+     new CleanWebpackPlugin(['/dist'])
      ...
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
    ...
  };
</code></pre></div><p>现在执行 <code>npm run build</code>，再检查 <code>/dist</code> 文件夹。如果一切顺利，你现在应该不会再看到旧的文件，只有构建后生成的文件！</p> <p>npm i clean-webpack-plugin@0.1.19 -D  装这个版本</p> <blockquote><p><em>由于最新版本变化@2.0.1</em>之前的写法已经不能使用：<code>new CleanWebpackPlugin(['/dist'])</code>。 官方文档地址：<a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/clean-webpack-plugin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 可以直接设置一个对象参考： <code>new CleanWebpackPlugin({cleanOnceBeforeBuildPatterns: ['**/*', '!static-files*']})</code></p></blockquote> <h3 id="加载图片与图片优化"><a href="#加载图片与图片优化" aria-hidden="true" class="header-anchor">#</a> 加载图片与图片优化</h3> <p>在 css 文件或者 sass 文件中添加如下代码</p> <div class="language- extra-class"><pre class="language-text"><code>$red: #900;
$size: 20px;

.box {
  height: 30px*2;
  font-size: $size;
  transform: translate3d( 0, 0, 0 );
+ background: url('../static/1.jpeg')
}Copy to clipboardErrorCopied
</code></pre></div><p>运行打包发现如下错误：</p> <div class="language- extra-class"><pre class="language-text"><code>ERROR in ./src/static/1.jpeg 1:0
Module parse failed: Unexpected character '�' (1:0)
You may need an appropriate loader to handle this file type.Copy to clipboardErrorCopied
</code></pre></div><p>解决方案：<code>file-loader</code>处理文件的导入</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev file-loader
</code></pre></div><p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ]
        },
+       {
+         test: /\.(png|svg|jpg|gif)$/,
+         use: [
+           'file-loader'
+         ]
+       }
      ]
    }
  };Copy to clipboardErrorCopied
</code></pre></div><p>此时运行打包，发现 dist 目录多了一个图片文件，另外报错不再出现。</p> <p>那更进一步，图片如何进行优化呢？</p> <p><code>image-webpack-loader</code>可以帮助我们对图片进行压缩和优化。</p> <div class="language- extra-class"><pre class="language-text"><code>npm install image-webpack-loader --save-dev
</code></pre></div><p>使用：webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ]
        },
        {
          test: /\.(png|svg|jpg|gif|jpeg|ico)$/,
          use: [
            'file-loader',
+           {
+             loader: 'image-webpack-loader',
+             options: {
+               mozjpeg: {
+                 progressive: true,
+                 quality: 65
+               },
+               optipng: {
+                 enabled: false,
+               },
+               pngquant: {
+                 quality: '65-90',
+                 speed: 4
+               },
+               gifsicle: {
+                 interlaced: false,
+               },
+               webp: {
+                 quality: 75
+               }
+             }
+           },
          ]
        }
      ]
    }
  };Copy to clipboardErrorCopied
</code></pre></div><p>此时在运行 webpack，发现会 生成的图片的大小会被压缩很多。</p> <h3 id="更进一步处理图片成-base64"><a href="#更进一步处理图片成-base64" aria-hidden="true" class="header-anchor">#</a> 更进一步处理图片成 base64</h3> <p><code>url-loader</code>功能类似于 file-loader，可以把 url 地址对应的文件，打包成 base64 的 DataURL，提高访问的效率。</p> <p>如何使用：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev url-loader
</code></pre></div><p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif|jpeg|ico|woff|woff2|eot|ttf|otf)$/,
        use: [
          {
            loader: 'url-loader', // 根据图片大小，把图片优化成base64
            options: {
              limit: 10000
            }
          },
          {
            loader: 'image-webpack-loader', // 先进行图片优化
            options: {
              mozjpeg: {
                progressive: true,
                quality: 65
              },
              optipng: {
                enabled: false
              },
              pngquant: {
                quality: '65-90',
                speed: 4
              },
              gifsicle: {
                interlaced: false
              },
              webp: {
                quality: 75
              }
            }
          }
        ]
      }
    ]
  }
};
</code></pre></div><h3 id="字体的处理（同图片）"><a href="#字体的处理（同图片）" aria-hidden="true" class="header-anchor">#</a> 字体的处理（同图片）</h3> <p>由于 css 中可能引用到自定义的字体，处理也是跟图片一致。</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ]
        },
        {
          test: /\.(png|svg|jpg|gif)$/,
          use: [
            'file-loader'
          ]
        },
+       {
+         test: /\.(woff|woff2|eot|ttf|otf)$/,
+         use: [
+           'file-loader'
+         ]
+       }
      ]
    }
  };
</code></pre></div><h2 id="开发相关辅助"><a href="#开发相关辅助" aria-hidden="true" class="header-anchor">#</a> 开发相关辅助</h2> <h3 id="合并两个webpack的js配置文件"><a href="#合并两个webpack的js配置文件" aria-hidden="true" class="header-anchor">#</a> 合并两个webpack的js配置文件</h3> <p>开发环境(development)和生产环境(production)配置文件有很多不同点，但是也有一部分是相同的配置内容，如果在两个配置文件中都添加相同的配置节点， 就非常不爽。</p> <p><code>webpack-merge</code> 的工具可以实现两个配置文件进合并，这样我们就可以把 开发环境和生产环境的公共配置抽取到一个公共的配置文件中。</p> <p>安装：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev webpack-merge
</code></pre></div><p>例如：</p> <p>project</p> <div class="language- extra-class"><pre class="language-text"><code>  webpack-demo
  |- package.json
- |- webpack.config.js 
+ |- webpack.common.js  公共
+ |- webpack.dev.js  开发阶段
+ |- webpack.prod.js  生产阶段
  |- /dist
  |- /src
    |- index.js
    |- math.js
  |- /node_modules
</code></pre></div><p>webpack.common.js</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|gif|jpeg|ico|woff|woff2|eot|ttf|otf)$/,
        use: [{
            loader: 'url-loader', // 根据图片大小，把图片优化成base64
            options: {
              limit: 10000
            }
          },
          {
            loader: 'image-webpack-loader', // 先进行图片优化
            options: {
              mozjpeg: {
                progressive: true,
                quality: 65
              },
              optipng: {
                enabled: false
              },
              pngquant: {
                quality: '65-90',
                speed: 4
              },
              gifsicle: {
                interlaced: false
              },
              webp: {
                quality: 75
              }
            }
          }
        ]
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: 'AICODER 全栈线下实习', // 默认值：Webpack App
      filename: 'main.html', // 默认值： 'index.html'
      template: path.resolve(__dirname, 'src/main.html'),
      minify: {
        collapseWhitespace: true,
        removeComments: true,
        removeAttributeQuotes: true // 移除属性的引号
      }
    }),
    new CleanWebpackPlugin(['dist']) // 清除dist
  ]
};
</code></pre></div><p>webpack.dev.js</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
const merge = require('webpack-merge');
const common = require('./webpack.common.js');

let devConfig = {
    mode: 'production',
    output: {
        filename: 'main.[hash].js',
        path: path.resolve(__dirname, './dist')
    },
    module: {
        rules: [{
            test: /\.(sa|sc|c)ss$/,
            use: [
                'style-loader',
                {
                    loader: 'css-loader',
                    options: {
                        sourceMap: true
                    }
                },
                {
                    loader: 'postcss-loader',
                    options: {
                        ident: 'postcss',
                        sourceMap: true,
                        plugins: loader =&gt; [require('autoprefixer')({
                            overrideBrowserslist: ['&gt; 0.15% in CN']
                        })]
                    }
                },
                {
                    loader: 'sass-loader',
                    options: {
                        sourceMap: true
                    }
                }
            ]
        }]
    }
};

module.exports = merge(common, devConfig)
</code></pre></div><p>webpack.prod.js</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');

const merge = require('webpack-merge');
const common = require('./webpack.common.js');

let prodConfig = module.exports = {
    mode: 'production',
    entry: './src/index.js',
    output: {
        filename: 'main.[hash].js',
        path: path.resolve(__dirname, './dist')
    },
    module: {
        rules: [{
            test: /\.(sa|sc|c)ss$/,
            use: [
                'style-loader',
                {
                    loader: 'css-loader'
                },
                {
                    loader: 'postcss-loader',
                    options: {
                        ident: 'postcss',
                        plugins: loader =&gt; [require('autoprefixer')({
                            overrideBrowserslist: ['&gt; 0.15% in CN']
                        })]
                    }
                },
                {
                    loader: 'sass-loader'
                }
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: '[name][hash].css',
            chunkFilename: '[id][hash].css'
        })
    ],
    optimization: {
        minimizer: [
            new UglifyJsPlugin({
                cache: true,
                parallel: true,
                sourceMap: true // 如果需要JS源映射，请设置为true
            }),
            new OptimizeCSSAssetsPlugin({})
        ]
    }
};

module.exports = merge(common, prodConfig)
</code></pre></div><h3 id="js-使用-source-map"><a href="#js-使用-source-map" aria-hidden="true" class="header-anchor">#</a> js 使用 source map</h3> <p>当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。</p> <p>使用 <code>inline-source-map</code> 选项，这有助于解释说明 js 原始出错的位置。（<strong>不要用于生产环境</strong>）：</p> <p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const CleanWebpackPlugin = require('clean-webpack-plugin');

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js'
    },
+   devtool: 'inline-source-map',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Development'
      })
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
  };Copy to clipboardErrorCopied
</code></pre></div><p><img src="https://malun666.github.io/aicoder_vip_doc/images/webpackinline.png" alt="inline-source-map"></p> <h3 id="监控文件变化，自动编译。使用观察模式"><a href="#监控文件变化，自动编译。使用观察模式" aria-hidden="true" class="header-anchor">#</a> 监控文件变化，自动编译。使用观察模式</h3> <p>每次修改完毕后，都手动编译异常痛苦。最简单解决的办法就是启动<code>watch</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>npx webpack --watch
</code></pre></div><p>当然可以添加到 npm 的 script 中</p> <p>package.json</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;name&quot;: &quot;development&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;main&quot;: &quot;webpack.config.js&quot;,
    &quot;scripts&quot;: {
     	&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    	&quot;dev&quot;: &quot;npx webpack --config webpack.dev.js&quot;,
    	&quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,
    	&quot;build&quot;: &quot;npx webpack --config webpack.prod.js&quot;
    },
    &quot;devDependencies&quot;: {
      &quot;clean-webpack-plugin&quot;: &quot;^0.1.16&quot;,
      &quot;css-loader&quot;: &quot;^0.28.4&quot;,
      &quot;csv-loader&quot;: &quot;^2.1.1&quot;,
      &quot;file-loader&quot;: &quot;^0.11.2&quot;,
      &quot;html-webpack-plugin&quot;: &quot;^2.29.0&quot;,
      &quot;style-loader&quot;: &quot;^0.18.2&quot;,
      &quot;webpack&quot;: &quot;^3.0.0&quot;,
      &quot;xml-loader&quot;: &quot;^1.2.1&quot;
    }
  }Copy to clipboardErrorCopied
</code></pre></div><p>但是有个 bug，就是每次我们修改 js 或者 css 文件后，要看到修改后的 html 的变化，需要我自己重新刷新页面。</p> <p>如何能不刷新页面，自动更新变化呢？</p> <h3 id="使用-webpack-dev-server-和热更新"><a href="#使用-webpack-dev-server-和热更新" aria-hidden="true" class="header-anchor">#</a> 使用 webpack-dev-server 和热更新</h3> <p>webpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev webpack-dev-server
</code></pre></div><p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const CleanWebpackPlugin = require('clean-webpack-plugin');

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js'
    },
    devtool: 'inline-source-map',
+   devServer: {
+     contentBase: './dist'
+   },
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Development'
      })
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
  };Copy to clipboardErrorCopied
</code></pre></div><p>启动此 webserver：</p> <div class="language- extra-class"><pre class="language-text"><code>webpack-dev-server --open
</code></pre></div><p><a href="https://webpack.docschina.org/configuration/dev-server/" target="_blank" rel="noopener noreferrer">官网其他配置<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language- extra-class"><pre class="language-text"><code>devServer: {
  clientLogLevel: 'warning', // 可能的值有 none, error, warning 或者 info（默认值)
  hot: true,  // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件
  contentBase:  path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录
  compress: true, // 一切服务都启用gzip 压缩
  host: '0.0.0.0', // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0
  port: 8080, // 端口
  open: true, // 是否打开浏览器
  overlay: {  // 出现错误或者警告的时候，是否覆盖页面线上错误消息。
    warnings: true,
    errors: true
  },
  publicPath: '/', // 此路径下的打包文件可在浏览器中访问。
  proxy: {  // 设置代理
    &quot;/api&quot;: {  // 访问api开头的请求，会跳转到  下面的target配置
      target: &quot;http://192.168.0.102:8080&quot;,
      pathRewrite: {&quot;^/api&quot; : &quot;/mockjsdata/5/api&quot;}
    }
  },
  quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。
  watchOptions: { // 监视文件相关的控制选项
    poll: true,   // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000
    ignored: /node_modules/, // 忽略监控的文件夹，正则
    aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟
  }
}
</code></pre></div><p>如何启用热更新呢？</p> <p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
+ const webpack = require('webpack');

  module.exports = {
    entry: {
       app: './src/index.js'
    },
    devtool: 'inline-source-map',
    devServer: {
      contentBase: './dist',
+     hot: true
    },
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Hot Module Replacement'
      }),
+     new webpack.NamedModulesPlugin(),  // 更容易查看(patch)的依赖
+     new webpack.HotModuleReplacementPlugin()  // 替换插件
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
  };
</code></pre></div><p>注意：配置入口文件时改成index.html</p> <h3 id="js启用babel转码"><a href="#js启用babel转码" aria-hidden="true" class="header-anchor">#</a> JS启用babel转码</h3> <p>虽然现代的浏览器已经兼容了96%以上的ES6的语法了，但是为了兼容老式的浏览器（IE8、9）我们需要把最新的ES6的语法转成ES5的。那么<code>babel</code>的loader就出场了。</p> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D babel-loader babel-core babel-preset-env

注意：npm i babel-loader@7 -D
</code></pre></div><p>用法</p> <p>在webpack的配置文件中，添加js的处理模块。</p> <div class="language- extra-class"><pre class="language-text"><code>module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /(node_modules)/,  // 加快编译速度，不包含node_modules文件夹内容
      use: {
        loader: 'babel-loader'
      }
    }
  ]
}
</code></pre></div><p>然后，在项目根目录下，添加babel的配置文件 <code>.babelrc</code>.</p> <p><code>.babelrc</code>文件如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;presets&quot;: [&quot;env&quot;]
}
</code></pre></div><p>最后，在入口js文件中，添加ES6的❤新语法：</p> <div class="language- extra-class"><pre class="language-text"><code>class Temp {
  show() {
    console.log('this.Age :', this.Age);
  }
  get Age() {
    return this._age;
  }
  set Age(val) {
    this._age = val + 1;
  }
}

let t = new Temp();
t.Age = 19;

t.show();
</code></pre></div><p>最后打包：</p> <div class="language- extra-class"><pre class="language-text"><code>npx webpack
</code></pre></div><p>最终打包后的js代码：</p> <div class="language- extra-class"><pre class="language-text"><code>var a = 1,
    b = 3,
    c = 9;

console.log('a :', a);
console.log('b :', b);
console.log('c :', c);

var Temp = function () {
  function Temp() {
    _classCallCheck(this, Temp);
  }

  _createClass(Temp, [{
    key: 'show',
    value: function show() {
      console.log('this.Age :', this.Age);
    }
  }, {
    key: 'Age',
    get: function get() {
      return this._age;
    },
    set: function set(val) {
      this._age = val + 1;
    }
  }]);

  return Temp;
}();

var t = new Temp();
t.Age = 19;

t.show();
</code></pre></div><h3 id="babel优化"><a href="#babel优化" aria-hidden="true" class="header-anchor">#</a> Babel优化</h3> <p>babel-loader可以配置如下几个options：</p> <ul><li><code>cacheDirectory</code>：默认值为 false。当有设置时，指定的目录将用来缓存 loader 的执行结果。之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程(recompilation process)。如果设置了一个空值 (loader: 'babel-loader?cacheDirectory') 或者 true (loader: babel-loader?cacheDirectory=true)，loader 将使用默认的缓存目录 node_modules/.cache/babel-loader，如果在任何根目录下都没有找到 node_modules 目录，将会降级回退到操作系统默认的临时文件目录。</li> <li><code>cacheIdentifier</code>：默认是一个由 babel-core 版本号，babel-loader 版本号，.babelrc 文件内容（存在的情况下），环境变量 BABEL_ENV 的值（没有时降级到 NODE_ENV）组成的字符串。可以设置为一个自定义的值，在 identifier 改变后，强制缓存失效。</li> <li><code>forceEnv</code>：默认将解析 BABEL_ENV 然后是 NODE_ENV。允许你在 loader 级别上覆盖 BABEL_ENV/NODE_ENV。对有不同 babel 配置的，客户端和服务端同构应用非常有用。</li></ul> <blockquote><p>注意：sourceMap 选项是被忽略的。当 webpack 配置了 sourceMap 时（通过 devtool 配置选项），将会自动生成 sourceMap。</p></blockquote> <p>babel 在每个文件都插入了辅助代码，使代码体积过大.babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。 默认情况下会被添加到每一个需要它的文件中。你可以引入 <code>babel runtime</code> 作为一个独立模块，来避免重复引入。</p> <p>安装：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install babel-plugin-transform-runtime --save-dev
npm install babel-runtime --save
</code></pre></div><p>配置：</p> <p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>rules: [
  // 'transform-runtime' 插件告诉 babel 要引用 runtime 来代替注入。
  {
    test: /\.js$/,
    exclude: /(node_modules|bower_components)/,
    use: {
      loader: 'babel-loader',
    }
  }
]
</code></pre></div><p>修改<code>.babelrc</code></p> <div class="language- extra-class"><pre class="language-text"><code>{
  &quot;presets&quot;: [&quot;env&quot;],
  &quot;plugins&quot;: [
    [&quot;transform-runtime&quot;, {
      &quot;helpers&quot;: true,
      &quot;polyfill&quot;: true,
      &quot;regenerator&quot;: true,
      &quot;moduleName&quot;: &quot;babel-runtime&quot;
    }]
  ]
}
</code></pre></div><p>此时，webpack打包的时候，会自动优化重复引入公共方法的问题。</p> <h3 id="eslint校验代码格式规范"><a href="#eslint校验代码格式规范" aria-hidden="true" class="header-anchor">#</a> ESLint校验代码格式规范</h3> <p>安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm install eslint --save-dev
npm install eslint-loader --save-dev

# 以下是用到的额外的需要安装的eslint的解释器、校验规则等
npm i -D babel-eslint standard
</code></pre></div><p>使用</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &quot;eslint-loader&quot;,
        options: {
          // eslint options (if necessary)
          fix: true
        }
      },
    ],
  },
  // ...
}

即：
{
    test: /\.js$/,
    exclude: /(node_modules|bower_components)/,
    use: [{
            loader: 'babel-loader',
        },
        {
            loader: &quot;eslint-loader&quot;,
            options: {
            // eslint options (if necessary)
            fix: true
        }
      }
    ]
 }
</code></pre></div><p>eslint配置可以直接放到webpack的配置文件中，也可以直接放到项目根目录的 <code>.eslintrc</code>中<a href="https://eslint.org/docs/developer-guide/nodejs-api#cliengine" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <div class="language- extra-class"><pre class="language-text"><code>// .eslintrc.js
// https://eslint.org/docs/user-guide/configuring
module.exports = {
  root: true,
  parserOptions: {
    parser: 'babel-eslint'
  },
  env: {
    browser: true
  },
  extends: [
    // https://github.com/standard/standard/blob/master/docs/RULES-en.md
    'standard'
  ],
  globals: {
    NODE_ENV: false
  },
  rules: {
    // allow async-await
    'generator-star-spacing': 'off',
    // allow debugger during development
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    // 添加，分号必须
    semi: ['error', 'always'],
    'no-unexpected-multiline': 'off',
    'space-before-function-paren': ['error', 'never'],
    // 'quotes': [&quot;error&quot;, &quot;double&quot;, { &quot;avoidEscape&quot;: true }]
    quotes: [
      'error',
      'single',
      {
        avoidEscape: true
      }
    ]
  }
};
</code></pre></div><p>设置eslint忽略的文件，同时vsCode安装eslint插件</p> <div class="language- extra-class"><pre class="language-text"><code>根目录下新建.eslintignore文件：
/dist/
/node_modules/
/*.js
</code></pre></div><p>此时eslint的配置就结束了。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/gangking/myBlog/edit/master/docs/studyNotes/Webpack.md" target="_blank" rel="noopener noreferrer">编辑文档</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2019-7-19 01:19:22</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myBlog/studyNotes/" class="prev router-link-active">
          介绍
        </a></span> <span class="next"><a href="/myBlog/studyNotes/React.html">
          React
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.bc1e53b8.js" defer></script><script src="/myBlog/assets/js/2.e7431746.js" defer></script><script src="/myBlog/assets/js/7.75128492.js" defer></script>
  </body>
</html>
