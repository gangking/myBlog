<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>NodeJs | MrXiong</title>
    <meta name="description" content="熊刚的个人博客首页，熊刚的技术作品，熊刚的生活成长">
    <link rel="icon" href="/myBlog/favicon.ico">
  <link rel="manifest" href="/myBlog/manifest.json">
    
    <link rel="preload" href="/myBlog/assets/css/0.styles.67215e50.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.9a205e1a.js" as="script"><link rel="preload" href="/myBlog/assets/js/2.c03f67b8.js" as="script"><link rel="preload" href="/myBlog/assets/js/21.6daa352d.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.1772eaaa.js"><link rel="prefetch" href="/myBlog/assets/js/11.b72fb48b.js"><link rel="prefetch" href="/myBlog/assets/js/12.c2a1f8a6.js"><link rel="prefetch" href="/myBlog/assets/js/13.8288193b.js"><link rel="prefetch" href="/myBlog/assets/js/14.952ed0f9.js"><link rel="prefetch" href="/myBlog/assets/js/15.c67c2b45.js"><link rel="prefetch" href="/myBlog/assets/js/16.e7bdeb4f.js"><link rel="prefetch" href="/myBlog/assets/js/17.775b6b87.js"><link rel="prefetch" href="/myBlog/assets/js/18.3eb29a8e.js"><link rel="prefetch" href="/myBlog/assets/js/19.21de1f76.js"><link rel="prefetch" href="/myBlog/assets/js/20.94867820.js"><link rel="prefetch" href="/myBlog/assets/js/22.5e365889.js"><link rel="prefetch" href="/myBlog/assets/js/23.b11b9f1d.js"><link rel="prefetch" href="/myBlog/assets/js/24.b5e770f4.js"><link rel="prefetch" href="/myBlog/assets/js/25.0d01a527.js"><link rel="prefetch" href="/myBlog/assets/js/26.cb940bf6.js"><link rel="prefetch" href="/myBlog/assets/js/27.ed621a85.js"><link rel="prefetch" href="/myBlog/assets/js/28.bcdc172f.js"><link rel="prefetch" href="/myBlog/assets/js/29.da4d0bf3.js"><link rel="prefetch" href="/myBlog/assets/js/3.0f742e16.js"><link rel="prefetch" href="/myBlog/assets/js/30.bbf7f9de.js"><link rel="prefetch" href="/myBlog/assets/js/31.f84eb563.js"><link rel="prefetch" href="/myBlog/assets/js/32.485bc394.js"><link rel="prefetch" href="/myBlog/assets/js/33.69f4ac61.js"><link rel="prefetch" href="/myBlog/assets/js/34.929ce270.js"><link rel="prefetch" href="/myBlog/assets/js/35.ecaae5f1.js"><link rel="prefetch" href="/myBlog/assets/js/36.fb388a85.js"><link rel="prefetch" href="/myBlog/assets/js/37.b0fc1645.js"><link rel="prefetch" href="/myBlog/assets/js/38.22c84c1e.js"><link rel="prefetch" href="/myBlog/assets/js/4.6c9ad4a3.js"><link rel="prefetch" href="/myBlog/assets/js/5.be02b664.js"><link rel="prefetch" href="/myBlog/assets/js/6.99df0c05.js"><link rel="prefetch" href="/myBlog/assets/js/7.872b75e5.js"><link rel="prefetch" href="/myBlog/assets/js/8.997b8e74.js"><link rel="prefetch" href="/myBlog/assets/js/9.3fefe930.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.67215e50.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><!----> <span class="site-name">MrXiong</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/myBlog/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/myBlog/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/myBlog/es6/" class="nav-link">ES6</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/node/" class="nav-link router-link-active">后端及实用技术</a></div><div class="nav-item"><a href="/myBlog/social/" class="nav-link">社交媒体</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端技术</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/myBlog/react/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/myBlog/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/myBlog/es6/" class="nav-link">ES6</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/node/" class="nav-link router-link-active">后端及实用技术</a></div><div class="nav-item"><a href="/myBlog/social/" class="nav-link">社交媒体</a></div><div class="nav-item"><a href="/myBlog/about/" class="nav-link">生活与创作</a></div> <a href="https://github.com/gangking/myBlog" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>后端及实用技术</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myBlog/node/" class="sidebar-link">介绍</a></li><li><a href="/myBlog/node/nodeJs.html" class="active sidebar-link">NodeJs</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#前端的主要工作是什么？" class="sidebar-link">前端的主要工作是什么？</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#后端的主要工作是什么？" class="sidebar-link">后端的主要工作是什么？</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#nodejs主要做什么？" class="sidebar-link">NodeJs主要做什么？</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#nodejs安装版本-lts-和-current-区别" class="sidebar-link">NodeJs安装版本:LTS 和 Current 区别</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#node的组成部分" class="sidebar-link">node的组成部分</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#浏览器中的js组成" class="sidebar-link">浏览器中的JS组成</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#let与const" class="sidebar-link">let与const</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#解构赋值" class="sidebar-link">解构赋值</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#字符串扩展" class="sidebar-link">字符串扩展</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#rest参数-和-字符串的扩展" class="sidebar-link">rest参数 和 字符串的扩展</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件操作" class="sidebar-link">文件操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件读取" class="sidebar-link">文件读取</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件写入" class="sidebar-link">文件写入</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件追加" class="sidebar-link">文件追加</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件复制" class="sidebar-link">文件复制</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#获取当前文件路径" class="sidebar-link">获取当前文件路径</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#返回路径中文件的文件名（不包括后缀）" class="sidebar-link">返回路径中文件的文件名（不包括后缀）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#返回文件扩展名" class="sidebar-link">返回文件扩展名</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文件操作案例：" class="sidebar-link">文件操作案例：</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#javascript-是单线程的一门语言" class="sidebar-link">Javascript 是单线程的一门语言</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#node中为什么大量使用异步方法" class="sidebar-link">Node中为什么大量使用异步方法</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#commonjs-模块规范和模块的使用" class="sidebar-link">CommonJS 模块规范和模块的使用</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#全局作用域和模块作用域" class="sidebar-link">全局作用域和模块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#global（全局作用域）" class="sidebar-link">global（全局作用域）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#require（模块引用）" class="sidebar-link">require（模块引用）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#exports（模块定义）" class="sidebar-link">exports（模块定义）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#module（模块标识）" class="sidebar-link">module（模块标识）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#module-exports-和-exports-的关系" class="sidebar-link">module.exports 和 exports 的关系</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#node-中的-javascript-由几部分组成" class="sidebar-link">Node 中的 Javascript 由几部分组成</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#模块分类" class="sidebar-link">模块分类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#核心模块" class="sidebar-link">核心模块</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#第三方模块" class="sidebar-link">第三方模块</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#用户自定义模块" class="sidebar-link">用户自定义模块</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#包" class="sidebar-link">包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#什么是包" class="sidebar-link">什么是包</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#规范的包结构" class="sidebar-link">规范的包结构</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#描述文件-package-json" class="sidebar-link">描述文件 package.json</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#npm" class="sidebar-link">npm</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#npm-的两层含义" class="sidebar-link">npm 的两层含义</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#安装和卸载全局包" class="sidebar-link">安装和卸载全局包</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#其它常用命令" class="sidebar-link">其它常用命令</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#解决-npm-下载慢问题" class="sidebar-link">解决 npm 下载慢问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#构建自己的web-server的服务器" class="sidebar-link">构建自己的web  Server的服务器</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#理解-bs-交互模型" class="sidebar-link">理解 BS 交互模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#理解-bs-交互模型-2" class="sidebar-link">理解 BS 交互模型</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#res和req对象（服务器所绑定的事件中使用）" class="sidebar-link">res和req对象（服务器所绑定的事件中使用）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#防止中文乱码（一般放在res-end之前）" class="sidebar-link">防止中文乱码（一般放在res.end之前）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#案例：引入静态资源" class="sidebar-link">案例：引入静态资源</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#结合模板引擎实现动态资源服务器" class="sidebar-link">结合模板引擎实现动态资源服务器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#导入art-template第三方模块" class="sidebar-link">导入art -template第三方模块</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#设置页面渲染数据" class="sidebar-link">设置页面渲染数据</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#生成模版字符串" class="sidebar-link">生成模版字符串</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#页面渲染" class="sidebar-link">页面渲染</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#使用-nodemon-工具来自动重启web服务器" class="sidebar-link">使用 nodemon 工具来自动重启web服务器</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#node-中的-web-快速开发框架-express" class="sidebar-link">Node 中的 Web 快速开发框架 - Express</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#定义什么是express：" class="sidebar-link">定义什么是Express：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#express-框架的安装和基本使用" class="sidebar-link">express 框架的安装和基本使用</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#服务器事件监听请求说明" class="sidebar-link">服务器事件监听请求说明</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#express独有的，直接防止中文乱码问题" class="sidebar-link">express独有的，直接防止中文乱码问题</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#使用-express-快速托管静态资源" class="sidebar-link">使用 express 快速托管静态资源</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#_1、先导入express框架" class="sidebar-link">1、先导入express框架</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#_2、托管静态资源" class="sidebar-link">2、托管静态资源</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#compression压缩功能" class="sidebar-link">compression压缩功能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#安装（项目路径下）" class="sidebar-link">安装（项目路径下）</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#导入compression" class="sidebar-link">导入compression</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#注册压缩资源中间件" class="sidebar-link">注册压缩资源中间件</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#虚拟目录-推荐" class="sidebar-link">虚拟目录 (推荐)</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#为-express-框架配置ejs模板引擎渲染动态页面" class="sidebar-link">为 express 框架配置ejs模板引擎渲染动态页面</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#注意res-render" class="sidebar-link">注意res.render</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#案例" class="sidebar-link">案例</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#使用-express-框架中提供的路由来分发请求" class="sidebar-link">使用 express 框架中提供的路由来分发请求</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#定义路由" class="sidebar-link">定义路由</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#使用自己的路由模块渲染页面" class="sidebar-link">使用自己的路由模块渲染页面</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#中间件-在express-框架里的概念" class="sidebar-link">中间件 在Express 框架里的概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#作用：" class="sidebar-link">作用：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#案例：" class="sidebar-link">案例：</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#如何在路由中拿到post提交过来的表单数据？" class="sidebar-link">如何在路由中拿到post提交过来的表单数据？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#关键思路：" class="sidebar-link">关键思路：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#自定义模拟解析表单数据" class="sidebar-link">自定义模拟解析表单数据</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#第三方中间件解析表单数据方法" class="sidebar-link">第三方中间件解析表单数据方法</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#路由一定要写在中间件之后" class="sidebar-link">路由一定要写在中间件之后</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#中间件的五种分类" class="sidebar-link">中间件的五种分类</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#模块加载机制" class="sidebar-link">模块加载机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#核心模块加载机制" class="sidebar-link">核心模块加载机制</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#第三方模块加载机制" class="sidebar-link">第三方模块加载机制</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#在加载用户模块查找规则" class="sidebar-link">在加载用户模块查找规则</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#第三方模块-moment-获取当前日期模块" class="sidebar-link">第三方模块(moment)  获取当前日期模块</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#模块查找规则：" class="sidebar-link">模块查找规则：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#ceud操作：增删改查" class="sidebar-link">CEUD操作：增删改查</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#从url地址中获取查询参数" class="sidebar-link">从URL地址中获取查询参数</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#从url地址路径中获取" class="sidebar-link">从URL地址路径中获取</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#从post表单中获取提交的数据" class="sidebar-link">从post表单中获取提交的数据</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#混合模式" class="sidebar-link">混合模式</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#前后端分离" class="sidebar-link">前后端分离</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#跨域问题" class="sidebar-link">跨域问题</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#jsonp-和-cors-的区别" class="sidebar-link">JSONP 和 CORS 的区别</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#英雄接口" class="sidebar-link">英雄接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#准备工作" class="sidebar-link">准备工作</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#知识点：" class="sidebar-link">知识点：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#思路：" class="sidebar-link">思路：</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#如何拿到get提交过来数据" class="sidebar-link">如何拿到get提交过来数据</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#第三方模块也可以发送ajax" class="sidebar-link">第三方模块也可以发送ajax</a></li></ul></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#文章" class="sidebar-link">文章</a></li><li class="sidebar-sub-header"><a href="/myBlog/node/nodeJs.html#作用：-2" class="sidebar-link">作用：</a></li></ul></li><li><a href="/myBlog/node/CodeManagement.html" class="sidebar-link">代码管理工具</a></li><li><a href="/myBlog/node/Xss.html" class="sidebar-link">防Xss</a></li><li><a href="/myBlog/node/mobileAdaptation.html" class="sidebar-link">移动端适配</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="nodejs"><a href="#nodejs" aria-hidden="true" class="header-anchor">#</a> NodeJs</h1> <h1 id="基本概念"><a href="#基本概念" aria-hidden="true" class="header-anchor">#</a> 基本概念</h1> <h2 id="前端的主要工作是什么？"><a href="#前端的主要工作是什么？" aria-hidden="true" class="header-anchor">#</a> 前端的主要工作是什么？</h2> <ol><li>绘制网页的页面（HTML）</li> <li>写CSS样式美化页面、写JS做网页交互（更多的是网页的特效）</li> <li>借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发</li> <li>使用前端的（框架）去完成界面的开发</li> <li>总结：前端的主要工作：用户能看到的东西，基本上都是前端做出来；</li></ol> <h2 id="后端的主要工作是什么？"><a href="#后端的主要工作是什么？" aria-hidden="true" class="header-anchor">#</a> 后端的主要工作是什么？</h2> <ol><li>后端为前端程序员暴露API接口；</li> <li>后端也要操作数据库；</li> <li>优化后端业务的性能；</li></ol> <h2 id="nodejs主要做什么？"><a href="#nodejs主要做什么？" aria-hidden="true" class="header-anchor">#</a> NodeJs主要做什么？</h2> <ul><li>目前这个阶段主要用来写后端的接口</li> <li>浏览器的JS在V8引擎中运行，node就是把V8引擎搬到了后台,即让JS能够在后台运行。</li></ul> <h2 id="nodejs安装版本-lts-和-current-区别"><a href="#nodejs安装版本-lts-和-current-区别" aria-hidden="true" class="header-anchor">#</a> NodeJs安装版本:LTS 和 Current 区别</h2> <ol><li>LTS 是长期稳定版的意思（这个安装包用起来比较稳定）【推荐在企业中使用】</li> <li>Current 是最新特征版，这个安装包中有最新的Node特性，但是，可能有一些潜藏的Bug未解决；【推荐学习或尝鲜去使用】</li></ol> <h2 id="node的组成部分"><a href="#node的组成部分" aria-hidden="true" class="header-anchor">#</a> node的组成部分</h2> <h3 id="浏览器中的js组成"><a href="#浏览器中的js组成" aria-hidden="true" class="header-anchor">#</a> 浏览器中的JS组成</h3> <ul><li>ECMAScript核心</li> <li>DOM</li> <li>BOM</li></ul> <p>node中的JS组成部分</p> <ul><li><p>ECMAScript（没有DOM，BOM）</p> <p>node中没有浏览器，所以不需要DOM和BOM</p></li> <li><p>全局成员</p> <p>console.log，setTimeout，setInterval</p></li> <li><p>模块系统</p> <p>node中的一些核心模块</p></li></ul> <h1 id="ecmascript6"><a href="#ecmascript6" aria-hidden="true" class="header-anchor">#</a> ECMAScript6</h1> <p>var定义变量的缺点：</p> <ul><li>1.变量提升的问题</li> <li>2.没有块级作用域（作用域不受花括号限制）</li></ul> <h2 id="let与const"><a href="#let与const" aria-hidden="true" class="header-anchor">#</a> let与const</h2> <ul><li><p>let 没有变量的提升用来代替var定义变量</p> <p>有{} 作用域</p></li> <li><p>const 没有变量的提升用来定义常量</p> <p>有{} 作用域 初始化的时候一定要赋值 , 赋值之后不能重新赋值</p> <p>如：const a = 1; a = 2; 发生错误</p></li></ul> <h2 id="解构赋值"><a href="#解构赋值" aria-hidden="true" class="header-anchor">#</a> 解构赋值</h2> <p>所谓的解构赋值，就是把 某个对象中的属性，当作变量，给解放出来，这样，今后就能够当作变量直接使用了</p> <ul><li>可以使用 <code>:</code>为解构出来的变量重命名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  // 对象的解构赋值,按照属性名解构
  const { name : name123, age, gender } = person
  console.log(name123)
  //数组的解构复制,按照顺序解构
  let arr: number[] = [2,3]
  let [num1,num2,num3] = arr
  console.log([num1,num2,num3])//num3=undfine
</code></pre></div><h2 id="字符串扩展"><a href="#字符串扩展" aria-hidden="true" class="header-anchor">#</a> 字符串扩展</h2> <ol><li><p>模板字符串</p></li> <li><p>startsWith() 和 endsWith()</p> <p>​	startsWith() 用来判断字符串，是否以指定的字符开头，如果是，返回值是 true，否则返回 false</p> <p>​	endsWith() 用来判断字符串，是否以指定的字符结尾；如果是，返回值是 true，否则返回 false</p></li> <li><p>padStart() 和 padEnd()</p> <p>​	在字符串前面或者后面追加字符串;</p> <p>​	参数一：表示填充完后长度为几位; 参数2：表示用什么填充</p></li></ol> <h2 id="rest参数-和-字符串的扩展"><a href="#rest参数-和-字符串的扩展" aria-hidden="true" class="header-anchor">#</a> rest参数 和 字符串的扩展</h2> <ul><li>rest参数： 在形参调用的位置 使用 ...args args是一个数组</li> <li>字符串的扩展： 在实参的位置 使用 ...arr</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  function show(...args){  // rest参数

  }

  var arr = [1,2,3,4]
  show(...arr);  //字符串的扩展
</code></pre></div><h2 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h2> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 标准定义   --&gt;
var add = () =&gt; {}
&lt;!-- 只有一个参数   --&gt;
var add = (x) =&gt; {console.log(x)}
var add = x =&gt; console.log(x)
&lt;!-- 只有一个参数,且只有一个返回值   --&gt;
var add = x =&gt; {return x}
var add = x =&gt; x
&lt;!-- 两个参数    --&gt;
var add = (x,y) =&gt; {return x+y}
var add = (x,y) =&gt; x + y
</code></pre></div><ol><li>箭头函数的特性： 箭头函数内部的 this, 永远和 箭头函数外部的 this 保持一致；</li> <li>箭头函数，本质上就是一个匿名函数</li> <li>注意： 如果我们省略了 右侧的 { }， 那么，默认就会把 右侧函数体中的代码执行结果，返回出去     (x, y) =&gt; { return  x + y }   可以简写成    (x, y) =&gt; x + y</li></ol> <h2 id="文件操作"><a href="#文件操作" aria-hidden="true" class="header-anchor">#</a> 文件操作</h2> <h3 id="文件读取"><a href="#文件读取" aria-hidden="true" class="header-anchor">#</a> 文件读取</h3> <p>fs.readFile(path,[,options],callback)</p> <ul><li>path 文件路径</li> <li>options 可选的字符编码 默认为null</li> <li>callback  回调函数
<ul><li>err 错误消息</li> <li>data 文件内容</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>  fs.readFile('./files/1.txt','utf-8',(err,dataStr)=&gt;{
    if(err) throw err
    console.log(dataStr)
  })
</code></pre></div><h3 id="文件写入"><a href="#文件写入" aria-hidden="true" class="header-anchor">#</a> 文件写入</h3> <p>fs.writeFile()</p> <div class="language-//会覆盖掉之前内容 extra-class"><pre class="language-text"><code>const fs = require(&quot;fs&quot;)
fs.writeFile(&quot;./file/demo2.txt&quot;,&quot;荆轲刺秦王123&quot;,(err)=&gt;{
    console.log(err)
    if(err) return console.log(&quot;写入文件失败！&quot;+err.message)
    console.log('写入文件成功！')
})
</code></pre></div><h3 id="文件追加"><a href="#文件追加" aria-hidden="true" class="header-anchor">#</a> 文件追加</h3> <p>fs.appendFile()</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require(&quot;fs&quot;);
fs.appendFile(&quot;./file/demo2.txt&quot;,&quot;\n纸巾&quot;,err=&gt;{
    if(err) console.log('追加内容失败'+err.message)
    console.log('追加内容成功！')
})
</code></pre></div><h3 id="文件复制"><a href="#文件复制" aria-hidden="true" class="header-anchor">#</a> 文件复制</h3> <p>方法1（原理）：</p> <div class="language- extra-class"><pre class="language-text"><code>fs.readFile(&quot;./file/demo2.txt&quot;,&quot;utf-8&quot;,(err,data)=&gt;{
    if(err) console.log(&quot;读取文件失败！&quot;+err.message)
    fs.writeFile(&quot;./file/dome-copy.txt&quot;,data,err=&gt;{
        if(err) console.log('写入文件失败'+err.message)
        console.log('写入文件成功！')
    })
})
</code></pre></div><p>方法2（推荐）：</p> <p>fs.copyFile()</p> <div class="language- extra-class"><pre class="language-text"><code>fs.copyFile(&quot;./file/demo2.txt&quot;,&quot;./file/dome-copy2.txt&quot;,err=&gt;{
    if(err) console.log('复制文件失败'+err.message)
        console.log('复制文件成功！')
})
</code></pre></div><h3 id="获取当前文件路径"><a href="#获取当前文件路径" aria-hidden="true" class="header-anchor">#</a> 获取当前文件路径</h3> <div class="language- extra-class"><pre class="language-text"><code>//导入文件模块
const fs = require(&quot;fs&quot;)
//倒入路径模块
const path = require('path');
//使用path.join()拼接地址（拼接地址可以是当前目录下任意文件）
//__dirname获取当前文件的目录
const newPath = path.join(__dirname,&quot;file/demo2.txt&quot;)
//最后根据文件路径读取文件
fs.readFile(newPath,&quot;utf-8&quot;,(err,data)=&gt;{
    if(err) return console.log(&quot;读取失败！&quot;+err.message)
    console.log(data)
})
</code></pre></div><p>补充：如果是直接访问当前文件可以：直接使用__filename</p> <p>拓展：</p> <div class="language- extra-class"><pre class="language-text"><code>2、读取文件另一种方式
const file = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)
const txtpath = path.join(__dirname,&quot;04函数扩展.js&quot;)
//读取文件
file.stat(txtpath,(err,data)=&gt;{
    if(err) return console.log(&quot;读取文件失败&quot;+message)
    console.log(&quot;文件读取成功！&quot;)
    console.log(data)
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>2、读取指定目录中所有文件的名称
const file = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)
file.readdir(__dirname,(err,filename)=&gt;{
    if(err) return console.log(&quot;读取文件名失败&quot;)
    console.log(&quot;读取文件名成功&quot;)
    console.log(filename)
})
</code></pre></div><h3 id="返回路径中文件的文件名（不包括后缀）"><a href="#返回路径中文件的文件名（不包括后缀）" aria-hidden="true" class="header-anchor">#</a> 返回路径中文件的文件名（不包括后缀）</h3> <div class="language- extra-class"><pre class="language-text"><code>//1、获取当前文件路径
const absPath = path.join(__filename)
2、获取.js文件的文件名
console.log(path.basename(absPath，'.js'))
</code></pre></div><h3 id="返回文件扩展名"><a href="#返回文件扩展名" aria-hidden="true" class="header-anchor">#</a> 返回文件扩展名</h3> <div class="language- extra-class"><pre class="language-text"><code>//1、获取当前文件路径
const absPath = path.join(__filename)
2、获取.js文件的扩展名
console.log(path.extname(absPath))//如果没有扩展名，返回为空
</code></pre></div><h3 id="文件操作案例："><a href="#文件操作案例：" aria-hidden="true" class="header-anchor">#</a> 文件操作案例：</h3> <p>获取当前目录下所有文件的信息（文件名、大小、是否为文件），并保存到info.txt文件中</p> <div class="language- extra-class"><pre class="language-text"><code>const file = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)
//1、获取路径下所有文件名称
file.readdir(__dirname, (err, filenames) =&gt; {
    if (err) return console.log(&quot;读取文件名称失败！&quot;)
    let infostr = ''
    let countflag = 0
    //2、循环遍历，所有文件
    filenames.forEach(item=&gt;{
        // (item)所有文件的文件名
        //3、拼接出每个文件的文件路径
        const absPath = path.join(__dirname,item)
        //4、读取所有文件信息
        file.stat(absPath,(err,txtinfo)=&gt;{
            const strinfo = `
            文件名：${item}\n
            文件大小：${txtinfo.size}\n
            是否为文件${txtinfo.isFile()}\n---------------------------\n`
            infostr += strinfo //每次都累加，相当于原有基础上拼接
            //5、将所有文件信息写入，指定文件中
            file.writeFile(path.join(__dirname,&quot;file/info.txt&quot;),infostr,(err)=&gt;{
                 if (err) return console.log(&quot;写入文件失败！&quot;)
                 console.log(&quot;写入文件信息成功&quot;)
            })
        })
    })
})
</code></pre></div><h1 id="javascript"><a href="#javascript" aria-hidden="true" class="header-anchor">#</a> Javascript</h1> <h2 id="javascript-是单线程的一门语言"><a href="#javascript-是单线程的一门语言" aria-hidden="true" class="header-anchor">#</a> Javascript 是单线程的一门语言</h2> <ol><li>什么是单线程：用户无法主动开启子线程，对于JS的运行来说，永远是主线程在执行关键代码；</li> <li>什么是多线程：用户可以主动开启子线程；    Thread  td = new Thread()</li> <li>在Node中，操作文件和网络都是比较耗时的操作；</li></ol> <h2 id="node中为什么大量使用异步方法"><a href="#node中为什么大量使用异步方法" aria-hidden="true" class="header-anchor">#</a> Node中为什么大量使用异步方法</h2> <ol><li>为什么要使用 异步方法呢： 因为 异步方法，不会阻塞CPU去执行其它任务；</li> <li>为什么在Node中不推荐使用同步呢： 因为 同步，需要一个一个执行，耗时的操作会阻碍CPU执行后续任务，因此，效率慢；</li></ol> <h2 id="commonjs-模块规范和模块的使用"><a href="#commonjs-模块规范和模块的使用" aria-hidden="true" class="header-anchor">#</a> CommonJS 模块规范和模块的使用</h2> <p>Node.js 实现了 CommonJS 模块化规范；</p> <ol><li>什么是 CommonJS 规范？
<ul><li>CommonJS 是<strong>为了实现 Javascript 的模块化</strong>，而制定的一套规范；</li></ul></li> <li>为什么 Javascript 需要模块化？
<ul><li>浏览器中的Javascript有没有实现模块化？（在一个JS文件中，能不能引用另外JS文件中的方法）</li> <li>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</li></ul></li> <li>如何实现 Javascript 的模块化？
<ul><li>为了统一大家编写模块时候的规则，方便各模块之间的依赖和调用，于是 CommonJS 规范就应运而生了。</li></ul></li> <li>那么，CommonJS 模块化规范，到底是个什么东西？？
<ul><li>定义了什么是模块</li> <li>一个JS模块中，如何引入其它的JS模块</li> <li>一个JS模块中，如何向外暴露一些成员，供其它模块调用；</li> <li>如果没有类似于 CommonJS 的规范，行不行？</li> <li>只有大家遵守同样的规范，才能够协作开发，方便别人，同时也方便自己；</li></ul></li></ol> <h2 id="全局作用域和模块作用域"><a href="#全局作用域和模块作用域" aria-hidden="true" class="header-anchor">#</a> 全局作用域和模块作用域</h2> <ol><li>每个JS文件，就是一个独立的模块，在这个JS文件中，所定义的任何方法、属性、变量、常量、对象，默认都属于 模块作用域，并不会属于 全局作用域；</li> <li>如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用<code>global.***</code>来挂载；</li></ol> <h3 id="global（全局作用域）"><a href="#global（全局作用域）" aria-hidden="true" class="header-anchor">#</a> global（全局作用域）</h3> <div class="language- extra-class"><pre class="language-text"><code>//定义1.js文件并写入代码
var b = 'this is txt2'
//将变量 b 设为 全局变量
global.b=b
</code></pre></div><h3 id="require（模块引用）"><a href="#require（模块引用）" aria-hidden="true" class="header-anchor">#</a> require（模块引用）</h3> <p>每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用；</p> <div class="language- extra-class"><pre class="language-text"><code>require(&quot;./1.js&quot;)
//只有当模块文件中的变量设置到全局时才能调用，因为被视作闭包
console.log(a)
</code></pre></div><h3 id="exports（模块定义）"><a href="#exports（模块定义）" aria-hidden="true" class="header-anchor">#</a> exports（模块定义）</h3> <p>每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，这个对象，将来，如果你想把自己的成员，暴露给别人使用，只需要把自己的成员，挂载到 exports 上就行了</p> <div class="language- extra-class"><pre class="language-text"><code>var a = '张三'
//暴露成员
exports.a = a
</code></pre></div><h3 id="module（模块标识）"><a href="#module（模块标识）" aria-hidden="true" class="header-anchor">#</a> module（模块标识）</h3> <p>这个 module 也是Common JS 规定的，它表示一个具体的模块，也是一个对象；</p> <div class="language- extra-class"><pre class="language-text"><code>var a = 45
//暴露成员
module.exports.a = a
</code></pre></div><h3 id="module-exports-和-exports-的关系"><a href="#module-exports-和-exports-的关系" aria-hidden="true" class="header-anchor">#</a> module.exports 和 exports 的关系</h3> <div class="language- extra-class"><pre class="language-text"><code>//1.JS
var a = '123'
var b = '126'
module.exports = {a:12}
exports.b = b
</code></pre></div><p>引用：</p> <div class="language- extra-class"><pre class="language-text"><code>const m1 = require(&quot;./m1.js&quot;)
console.log(m1)
// 都指向同一空对象，但是对外暴露的对象以module为准
</code></pre></div><p>所以，向外暴露成员时。推荐使用（module.exports）</p> <h1 id="node结构"><a href="#node结构" aria-hidden="true" class="header-anchor">#</a> Node结构</h1> <h2 id="node-中的-javascript-由几部分组成"><a href="#node-中的-javascript-由几部分组成" aria-hidden="true" class="header-anchor">#</a> Node 中的 Javascript 由几部分组成</h2> <ol><li>ECMAScript 核心</li> <li>全局成员</li> <li>模块系统成员
<ul><li>模块系统成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块</li></ul></li></ol> <h2 id="模块分类"><a href="#模块分类" aria-hidden="true" class="header-anchor">#</a> 模块分类</h2> <h3 id="核心模块"><a href="#核心模块" aria-hidden="true" class="header-anchor">#</a> 核心模块</h3> <ol><li>什么是核心模块：由Node官方提供的好用的模块，叫做核心模块；只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块；</li> <li>如何使用核心模块：<code>require('核心模块标识符')</code></li></ol> <h3 id="第三方模块"><a href="#第三方模块" aria-hidden="true" class="header-anchor">#</a> 第三方模块</h3> <ol><li>什么是第三方模块：一些非官方提供的模块，叫做第三方模块；注意，第三方模块，并不在我们的计算机上，如果大家需要使用某些第三方模块，必须去一个叫做 <code>NPM</code> 的网站上搜索并下载才能使用；</li> <li>如何使用第三方模块：
<ul><li>先从 npm 官网上下载指定的第三方模块</li> <li>使用 <code>require('第三方模块的名称标识符')</code>来导入这个模块</li> <li>根据 第三方模块的 官方文档，尝试使用</li></ul></li></ol> <h3 id="用户自定义模块"><a href="#用户自定义模块" aria-hidden="true" class="header-anchor">#</a> 用户自定义模块</h3> <ol><li>什么是用户模块：程序员自己写的JS文件，就叫做 用户自定义模块；</li> <li>如何使用用户模块：<code>require('路径标识符')</code></li></ol> <div class="language- extra-class"><pre class="language-text"><code>const app = require('./lib/index')
</code></pre></div><h2 id="包"><a href="#包" aria-hidden="true" class="header-anchor">#</a> 包</h2> <h3 id="什么是包"><a href="#什么是包" aria-hidden="true" class="header-anchor">#</a> 什么是包</h3> <ol><li>英文名叫做 <code>Packages</code>，包是在模块基础上更深一步的抽象，目的是：方便分发推广基于 CommonJS 规范实现的 应用程序 或 类库；</li> <li>包可以看作是 模块、代码 和 其它资源 组合起来形成的 独立作用域；</li></ol> <h3 id="规范的包结构"><a href="#规范的包结构" aria-hidden="true" class="header-anchor">#</a> 规范的包结构</h3> <ol><li><strong>包都要以一个单独的目录而存在</strong>；</li> <li><strong><code>package.json</code> 必须在包的顶层目录下</strong>；</li> <li><strong><code>package.json</code> 文件必须符合 JSON 格式，并且必须包含如下三个属性：<code>name</code>, <code>version</code>, <code>main</code></strong> <ul><li>name:  包的名字</li> <li>version: 包的版本号</li> <li>main: 表示包的入口文件</li></ul></li> <li>二进制文件应该在<strong>bin目录</strong>下;</li> <li>javaScript代码应该在<strong>lib目录</strong>下;</li> <li>文档应该在<strong>doc目录</strong>下;</li> <li>单元测试应该在<strong>test目录</strong>下;</li> <li>Node.js对包要求并没有那么严格，只要顶层目录下有<code>package.json</code>，并<strong>符合基本规范</strong>即可;</li></ol> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;name&quot;:&quot;mycalc&quot;,
    &quot;version&quot;:&quot;1.0.0&quot;,
    &quot;main&quot;:&quot;./lib/index.js&quot;
}
</code></pre></div><p>外界使用就必须先找到main： index.js文件（要引用包应该在包的同级目录下创建app.js文件）</p> <div class="language- extra-class"><pre class="language-text"><code>const app = require('./lib/index') //引入自自定义模块
console.log(app)
</code></pre></div><h3 id="描述文件-package-json"><a href="#描述文件-package-json" aria-hidden="true" class="header-anchor">#</a> 描述文件 package.json</h3> <div class="language- extra-class"><pre class="language-text"><code>name：包的名称，必须是唯一
description：包的简要说明
version：符合语义化版本识别规范的版本字符串
keywords：关键字数据，通常用于搜索
maintainers：维护者数组，每个元素要包含name、email、web可选字段
contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素
bugs：提交bug的地址，可以是网址或者电子邮件地址
licenses：许可证数组，每个元素要包含type和url字段
repositories：仓库托管地址数组，每个元素要包含type、url和path字段
dependencies：包的依赖，一个关联数组，由包名称和版本号组成。
devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项
</code></pre></div><h2 id="npm"><a href="#npm" aria-hidden="true" class="header-anchor">#</a> npm</h2> <h3 id="npm-的两层含义"><a href="#npm-的两层含义" aria-hidden="true" class="header-anchor">#</a> npm 的两层含义</h3> <ol><li>NPM 是一个 第三方模块的托管网站，指的就是<code>https://www.npmjs.com/</code>；</li> <li>NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具；</li></ol> <h3 id="安装和卸载全局包"><a href="#安装和卸载全局包" aria-hidden="true" class="header-anchor">#</a> 安装和卸载全局包</h3> <ol><li>什么是全局的包：通过  <code>npm install 包名 -g</code> 方式安装的包，都安装到了全局；一般全局的安装目录是<code>C:\Users\自己的用户文件夹\AppData\Roaming\npm</code></li> <li><strong>如果拿到一个空项目，必须先初始化一个<code>package.json</code>的配置文件，<code>npm init</code>或者<code>npm init -y</code></strong>*</li> <li>运行<code>npm i 包名 --save</code>去安装指定的包，本地安装的包，都安装到了<code>node_modules</code>的目录下</li> <li>如果大家用的是npm 5.x的版本，可以不指定<code>--save</code>命令，如果用的是 npm 3.x 的版本，则需要手动指定 <code>--save</code>, 同时，<code>--save</code>有缩写形式，是：<code>-S</code></li> <li><code>package-lock.json</code>文件中记录了曾经装过的包的下载地址，方便下次直接下载包；</li></ol> <h3 id="其它常用命令"><a href="#其它常用命令" aria-hidden="true" class="header-anchor">#</a> 其它常用命令</h3> <ol><li><code>--save-dev</code>它的缩写是<code>-D</code></li> <li>注意：<code>dependencies</code>节点，表示项目上线部署时候需要的依赖项；<code>devDependencies</code>节点，表示项目在开发阶段需要的依赖项，但是<strong>当项目要部署上线了</strong>，<code>devDependencies</code>节点中的包**，就不再需要了！**</li> <li>注意：当使用<code>npm i</code>快速装包的时候，npm会检查<code>package.json</code>文件中，所有的依赖项，然后都为我们安装到项目中</li> <li><code>--production</code> 表示只安装 <code>dependencies</code> 节点下，记录的包，不安装<code>devDependencies</code>节点下的包；当项目要上线了，才会使用<code>--production</code>命令</li></ol> <h3 id="解决-npm-下载慢问题"><a href="#解决-npm-下载慢问题" aria-hidden="true" class="header-anchor">#</a> 解决 npm 下载慢问题</h3> <ol><li>默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以安装一个工具，叫做<code>nrm</code>，里面记录了好多下载NPM包的服务器地址，可以让我们方便的切换下载包时候请求的服务器；</li> <li>运行<code>npm i nrm -g</code>（注意：只要是工具，一般都是全局 -g 安装）</li> <li>当装完 nrm 之后，可以运行<code>nrm ls</code> 查看所有可用的服务器列表</li> <li>可使用<code>nrm use 服务器名称</code>来切换下载包时候的服务器地址</li></ol> <p>注意：还可以使用工具yarn来代替此工具，更快！</p> <ul><li>npm i yarn -v//和nrm作用一样，下载更快</li> <li>yarn add '要安装的包'</li> <li>或者 yarn install 安装全局</li></ul> <h2 id="构建自己的web-server的服务器"><a href="#构建自己的web-server的服务器" aria-hidden="true" class="header-anchor">#</a> 构建自己的web  Server的服务器</h2> <ol><li><h4 id="导入提供的核心模块"><a href="#导入提供的核心模块" aria-hidden="true" class="header-anchor">#</a> 导入提供的核心模块</h4> <div class="language- extra-class"><pre class="language-text"><code>const http = require(&quot;http&quot;)
</code></pre></div></li> <li><h4 id="创建服务器"><a href="#创建服务器" aria-hidden="true" class="header-anchor">#</a> 创建服务器</h4> <div class="language- extra-class"><pre class="language-text"><code>const server = http.createServer();
</code></pre></div></li> <li><h4 id="为服务器绑定响应事件"><a href="#为服务器绑定响应事件" aria-hidden="true" class="header-anchor">#</a> 为服务器绑定响应事件</h4> <div class="language- extra-class"><pre class="language-text"><code>server.on(&quot;request&quot;,function(req,res){
    console.log(&quot;ok&quot;)
    res.end(&quot;服务器返回数据&quot;)
})
</code></pre></div></li> <li><h4 id="启动服务器"><a href="#启动服务器" aria-hidden="true" class="header-anchor">#</a> 启动服务器</h4> <div class="language- extra-class"><pre class="language-text"><code>//4、启动服务器
//端口号，ip地址(不写默认监听127.0.0.1),回调函数
server.listen(3000,function(){
    console.log(&quot;通知服务器已经启动！&quot;)
})
</code></pre></div></li></ol> <h2 id="理解-bs-交互模型"><a href="#理解-bs-交互模型" aria-hidden="true" class="header-anchor">#</a> 理解 BS 交互模型</h2> <h3 id="理解-bs-交互模型-2"><a href="#理解-bs-交互模型-2" aria-hidden="true" class="header-anchor">#</a> 理解 BS 交互模型</h3> <p>B/S：表示  Browser / Server        C/S     Client / Server</p> <ol><li>什么是服务器：在网络节点中，专门对外提供资源服务的一台电脑；</li> <li>什么是客户端：在网络节点中，专门用来消耗或呈现服务器中返回的数据的电脑；</li> <li>什么是静态资源：像 .js ,  .css, .jpg,  .html   ；所谓的静态资源，就是无需数据交互，服务器直接把资源读取，并响应给客户端就完事儿；</li> <li>什么是动态资源：当一些资源，服务器上并没有现成的，需要现在服务器端，做一层处理，最后把处理的结果返回给客户端，这样的资源，叫做动态资源；</li> <li>HTTP 协议的通信模型：<code>请求 - 处理 - 响应</code>的过程；</li></ol> <h3 id="res和req对象（服务器所绑定的事件中使用）"><a href="#res和req对象（服务器所绑定的事件中使用）" aria-hidden="true" class="header-anchor">#</a> res和req对象（服务器所绑定的事件中使用）</h3> <ul><li><p>返回请求数据</p> <div class="language- extra-class"><pre class="language-text"><code>res.end(&quot;服务器返回数据&quot;)
</code></pre></div></li> <li><p>获取请求路径</p> <div class="language- extra-class"><pre class="language-text"><code>//拿到请求的url地址
console.log(req.url)
</code></pre></div></li> <li><p>获取请求方式</p> <div class="language- extra-class"><pre class="language-text"><code>//拿到请求类型那，toLowerCase转换成小写
console.log(req.method)

</code></pre></div></li></ul> <h3 id="防止中文乱码（一般放在res-end之前）"><a href="#防止中文乱码（一般放在res-end之前）" aria-hidden="true" class="header-anchor">#</a> 防止中文乱码（一般放在res.end之前）</h3> <div class="language- extra-class"><pre class="language-text"><code>//参数1：数值类型状态码：200成功、300重定向404找不到，500aa类型错误
//参数2：配置对象
res.writeHeader(200,{
    'Content-Type':&quot;text/html;charset=utf-8&quot;
})//制定编码格式
res.end(&quot;请求类型：&quot;+req.method + &quot;；请求地址：&quot; +req.url)

</code></pre></div><h3 id="案例：引入静态资源"><a href="#案例：引入静态资源" aria-hidden="true" class="header-anchor">#</a> 案例：引入静态资源</h3> <div class="language- extra-class"><pre class="language-text"><code>const http = require(&quot;http&quot;)
const server = http.createServer()
const file = require(&quot;fs&quot;)
const path = require(&quot;path&quot;)
server.on(&quot;request&quot;, (req, res) =&gt; {
    const url = req.url
    getHtml(res, url)
})
server.listen(3000, function () {
    console.log(&quot;http://127.0.0.1:3000&quot;)
})
function getHtml(res, url) {
    // res.writeHead(200, {&quot;Content-Type&quot;:&quot;image/jpeg&quot;});
    file.readFile(path.join(__dirname, url), 'utf-8', (err, data) =&gt; {
        if (err) return res.end('404，您访问的页面未找到，炸了！！')
        if (url === '/asset/image/hong.jpg') {
            res.writeHead(200, {&quot;Content-Type&quot;:&quot;image/jpeg&quot;});//指定资源的编码格式
            res.end(data)
        } else {
            res.end(data)
        }
    })
}

</code></pre></div><h2 id="结合模板引擎实现动态资源服务器"><a href="#结合模板引擎实现动态资源服务器" aria-hidden="true" class="header-anchor">#</a> 结合模板引擎实现动态资源服务器</h2> <h3 id="导入art-template第三方模块"><a href="#导入art-template第三方模块" aria-hidden="true" class="header-anchor">#</a> 导入art -template第三方模块</h3> <div class="language- extra-class"><pre class="language-text"><code>const template = require(&quot;art-template&quot;)

</code></pre></div><h3 id="设置页面渲染数据"><a href="#设置页面渲染数据" aria-hidden="true" class="header-anchor">#</a> 设置页面渲染数据</h3> <div class="language- extra-class"><pre class="language-text"><code>//设置页面渲染数据
    const person = {
        name:'熊大大',
        age:21,
        hobby:['吃饭','睡觉','敲代码']
    }

</code></pre></div><h3 id="生成模版字符串"><a href="#生成模版字符串" aria-hidden="true" class="header-anchor">#</a> 生成模版字符串</h3> <div class="language- extra-class"><pre class="language-text"><code>//参数1为模版文件绝对路径
const htmlStr = template(path.join(__dirname,'asset/index.html'),person)
res.end(htmlStr)

</code></pre></div><h3 id="页面渲染"><a href="#页面渲染" aria-hidden="true" class="header-anchor">#</a> 页面渲染</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
        &lt;li&gt;姓名：&lt;%=name%&gt;&lt;/li&gt;
        &lt;li&gt;年龄：&lt;%=age%&gt;&lt;/li&gt;
        &lt;li&gt;爱好：
            &lt;ul&gt;
                &lt;li&gt;&lt;%=hobby[0]%&gt;&lt;/li&gt;
                &lt;li&gt;&lt;%=hobby[1]%&gt;&lt;/li&gt;
                &lt;li&gt;&lt;%=hobby[2]%&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;

</code></pre></div><p>完整案例：</p> <div class="language- extra-class"><pre class="language-text"><code>const http = require(&quot;http&quot;)
const path = require(&quot;path&quot;)
//导入art -template第三方模块
const template = require(&quot;art-template&quot;)
const server = http.createServer()
server.on('request',(req,res)=&gt;{
    //设置页面渲染数据
    const person = {
        name:'熊大大',
        age:21,
        hobby:['吃饭','睡觉','敲代码']
    }
    //参数1为模版文件绝对路径
    const htmlStr = template(path.join(__dirname,'asset/index.html'),person)
    res.end(htmlStr)
})
server.listen(3000,function(){
    console.log(&quot;http://127.0.0.1:3000&quot;)
})

</code></pre></div><h2 id="使用-nodemon-工具来自动重启web服务器"><a href="#使用-nodemon-工具来自动重启web服务器" aria-hidden="true" class="header-anchor">#</a> 使用 <code>nodemon</code> 工具来自动重启web服务器</h2> <ul><li>这个工具的作用：能够实时监听 web 服务器中，代码的改变，只要代码被修改并保存了，则 nodemon 工具，会自动重新启动 web 服务器；</li> <li>运行 <code>npm i nodemon -g</code> 就能够在全局环境中，安装这个工具了</li> <li>当安装完毕 <code>nodemon</code> 之后，就可以 使用 <code>nodemon 要执行的js文件路径</code> 来运行JS文件了</li> <li>今后在开发Web项目的时候，推荐使用 nodemon 来执行 web 服务器</li></ul> <h2 id="node-中的-web-快速开发框架-express"><a href="#node-中的-web-快速开发框架-express" aria-hidden="true" class="header-anchor">#</a> Node 中的 Web 快速开发框架 - Express</h2> <h3 id="定义什么是express："><a href="#定义什么是express：" aria-hidden="true" class="header-anchor">#</a> 定义什么是Express：</h3> <ol><li>基于 Node.js 后端Javascript平台之上，开发出来的一套Web开发框架；</li> <li>Express中，基于 原生Node的特性，做了进一步的封装，提供了一些更加好用的方法，来提高Web开发的体验；</li> <li>Express中，并没有覆盖或者删除原生的http模块方法；</li></ol> <h3 id="express-框架的安装和基本使用"><a href="#express-框架的安装和基本使用" aria-hidden="true" class="header-anchor">#</a> express 框架的安装和基本使用</h3> <ol><li><p>直接运行 <code>npm install express --save</code> 就可以安装Express框架了</p></li> <li><p>导入模块</p> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')

</code></pre></div></li> <li><p>创建服务器</p> <div class="language- extra-class"><pre class="language-text"><code>const app = express()

</code></pre></div></li> <li><p>事件监听</p> <div class="language- extra-class"><pre class="language-text"><code>app.get('/',function(req,res){
    //这里是原生方法的api
    // res.end('&lt;h1&gt;这是express中开启的服务器，查看是否会乱码（会）&lt;/h1&gt;')
    //express独有的，可以直接防止中文乱码问题
    res.send('&lt;h1&gt;这是express中开启的服务器，查看是否乱码（会）&lt;/h1&gt;')
})

</code></pre></div></li> <li><p>启动服务器</p> <div class="language- extra-class"><pre class="language-text"><code>app.listen(4000,()=&gt;{
    console.log('express server running at http://127.0.0.1:4000')
})

</code></pre></div></li></ol> <h2 id="服务器事件监听请求说明"><a href="#服务器事件监听请求说明" aria-hidden="true" class="header-anchor">#</a> 服务器事件监听请求说明</h2> <ul><li>app.get只监听get请求,app.post。。。</li> <li>app.all表示监听所有类型请求</li></ul> <h2 id="express独有的，直接防止中文乱码问题"><a href="#express独有的，直接防止中文乱码问题" aria-hidden="true" class="header-anchor">#</a> express独有的，直接防止中文乱码问题</h2> <div class="language- extra-class"><pre class="language-text"><code>//这里是原生方法的api
// res.end('&lt;h1&gt;这是express中开启的服务器，查看是否会乱码（会）&lt;/h1&gt;')
//express独有的，可以直接防止中文乱码问题
res.send('&lt;h1&gt;这是express中开启的服务器，查看是否乱码（会）&lt;/h1&gt;')

</code></pre></div><h2 id="使用-express-快速托管静态资源"><a href="#使用-express-快速托管静态资源" aria-hidden="true" class="header-anchor">#</a> 使用 express 快速托管静态资源</h2> <ol><li>如果我们网站中，有很多静态资源需要被外界访问，express 框架，为我们提供了一个 内置的（中间件）  <code>express.static('静态资源目录')</code>  ， 来快速托管指定目录下的<strong>所有静态资源文件；</strong></li> <li>用法： <code>app.use(express.static('public'));</code></li></ol> <ul><li>其中， <code>express.static</code> 是一个express的内置中间件；</li> <li><code>app.use()</code>方法，是专门用来注册 中间件；</li></ul> <ol><li>当使用 第二步中的方法，把指定目录托管为静态资源目录之后，那么，这一层被托管的目录，不应该出现在 资源访问的 URL地址中；</li> <li>在一个Web项目中，我们可以多次调用<code>app.use(express.static())</code></li> <li>在多次调用 express.static 的时候，如果文件名称有重复的，则以先注册的中间件为主！</li> <li>如果项目要部署了，推荐大家配置一个叫做<code>compression</code>的中间件，它能够开启服务器的GZip压缩功能；</li></ol> <h3 id="_1、先导入express框架"><a href="#_1、先导入express框架" aria-hidden="true" class="header-anchor">#</a> 1、先导入express框架</h3> <div class="language- extra-class"><pre class="language-text"><code>const express = require(&quot;express&quot;)

</code></pre></div><h3 id="_2、托管静态资源"><a href="#_2、托管静态资源" aria-hidden="true" class="header-anchor">#</a> 2、托管静态资源</h3> <div class="language- extra-class"><pre class="language-text"><code>//快速托管静态资源文件，静态文件所在目录作为参数传递即可
app.use(express.static('./view'));//asset下的页面文件都可访问了
app.use(express.static('./asset'));//asset下的静态资源文件都可访问了

</code></pre></div><p>注意：</p> <ol><li>启动服务器后：默认自动启动view目录下的index.html文件</li> <li>index.html文件中，填写资源引用路径时就不用再写/asset路径：</li></ol> <div class="language- extra-class"><pre class="language-text"><code> &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/index.css&quot;&gt;
 &lt;script src=&quot;/js/index.js&quot;&gt;&lt;/script&gt;

</code></pre></div><h2 id="compression压缩功能"><a href="#compression压缩功能" aria-hidden="true" class="header-anchor">#</a> compression压缩功能</h2> <ul><li>帮助网页加载(项目部署阶段使用最佳)</li></ul> <h3 id="安装（项目路径下）"><a href="#安装（项目路径下）" aria-hidden="true" class="header-anchor">#</a> 安装（项目路径下）</h3> <div class="language- extra-class"><pre class="language-text"><code>npm i compression

</code></pre></div><h3 id="导入compression"><a href="#导入compression" aria-hidden="true" class="header-anchor">#</a> 导入compression</h3> <div class="language- extra-class"><pre class="language-text"><code>const compression = require('compression')

</code></pre></div><h3 id="注册压缩资源中间件"><a href="#注册压缩资源中间件" aria-hidden="true" class="header-anchor">#</a> 注册压缩资源中间件</h3> <div class="language- extra-class"><pre class="language-text"><code>//注册压缩资源中间键
server.use(compression())

</code></pre></div><h2 id="虚拟目录-推荐"><a href="#虚拟目录-推荐" aria-hidden="true" class="header-anchor">#</a> 虚拟目录 (推荐)</h2> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')
const app = express()
app.use(express.static('./view'))
//访问资源时可以设置虚拟目录
app.use('/asset',express.static('./asset'))
//这样子文件中就可以通过/static/css/xxx.css的方式访问public下面的内容了
app.listen(3000,()=&gt;{
    console.log('http://127.0.0.1:3000')
})

</code></pre></div><h2 id="为-express-框架配置ejs模板引擎渲染动态页面"><a href="#为-express-框架配置ejs模板引擎渲染动态页面" aria-hidden="true" class="header-anchor">#</a> 为 express 框架配置ejs模板引擎渲染动态页面</h2> <ul><li>安装 ejs 模板引擎<code>npm i ejs -S</code></li> <li>使用 app.set() 配置默认的模板引擎 <code>app.set('view engine', 'ejs')</code></li> <li>使用 app.set() 配置默认模板页面的存放路径 <code>app.set('views', './views')</code></li> <li>使用 res.render() 来渲染模板页面<code>res.render('index.ejs', { 要渲染的数据对象 })</code>，注意，模板页面的 后缀名，可以省略不写！</li></ul> <h3 id="注意res-render"><a href="#注意res-render" aria-hidden="true" class="header-anchor">#</a> 注意res.render</h3> <p><code>res.render('index.ejs', { 要渲染的数据对象 })</code>，模板页面的 后缀名（ejs），可以省略不写！</p> <h3 id="案例"><a href="#案例" aria-hidden="true" class="header-anchor">#</a> 案例</h3> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')
const path = require('path')
const app = express()
// 配置模版引擎1步，（express更加适配）
// 使用 app.set() 配置默认的模板引擎
app.set('view engine','ejs')

// 配置模版引擎2步
// 配置默认模版存放路径
// 注意：默认情况下，无法直接使用，因为express并没有默认为我们提供默认模版引擎
// 所以再调用之前，先认为指定使用哪个模版引擎渲染页面
// 参数1：固定写法，参数2：模版页面存放路径
app.set('views','./view')

const person = 
    {
        name:'瑞东',
        age:'21',
        wife:'西田麻衣',
        hobby:['吃饭','旅游','嘿嘿嘿']
    }

app.get('/',(req,res)=&gt;{
    //配置模版引擎3步
   // sendFile()只能渲染静态页面
    // //express独有的；参数1：要渲染的页面,参数2：要渲染的数据对象 
    // res.render();//渲染动态页面
    res.render('index.ejs',person)
})

app.listen(3100,()=&gt;{
    console.log('http://127.0.0.1:3100')
})

</code></pre></div><h2 id="使用-express-框架中提供的路由来分发请求"><a href="#使用-express-框架中提供的路由来分发请求" aria-hidden="true" class="header-anchor">#</a> 使用 express 框架中提供的路由来分发请求</h2> <ol><li>什么叫做路由：前端请求的URL地址，都要对应一个后端的处理函数，那么 这种URL地址到 处理函数之间的对应关系，就叫做后端路由；</li> <li>在Express中，路由主要负责 分发请求处理的；</li></ol> <h3 id="定义路由"><a href="#定义路由" aria-hidden="true" class="header-anchor">#</a> 定义路由</h3> <ul><li>创建03.roter.js'文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//导入框架
const express= require(&quot;express&quot;)
//创建一个路由对象
const router = express.Router()
const personhu = {
    name:'胡歌',
    age:'21',
    wife:'刘亦菲',
    hobby:['吃饭','旅游','嘿嘿嘿']
}
//发起不同的路由请求
router.get('/',(req,res)=&gt;{
    res.render('rotezhang.ejs',personhu)
})
router.get('/routhu',(req,res)=&gt;{
    res.render('routhu.ejs',personhu)
})
router.get('/routliu',(req,res)=&gt;{
    res.render('routliu.ejs',personhu)
})
//导出路由对象
module.exports = router;//暴露路由对象

</code></pre></div><h3 id="使用自己的路由模块渲染页面"><a href="#使用自己的路由模块渲染页面" aria-hidden="true" class="header-anchor">#</a> 使用自己的路由模块渲染页面</h3> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')
const app = express()
//托管静态资源
app.set('view engine','ejs')
app.set('views','./view')
// 导入自己的路由模块
const router = require('./03.roter.js')
//再将路由对象注册在app服务器中
app.use(router)
app.listen(3000,()=&gt;{
    console.log(&quot;http://127.0.0.1:3000&quot;)
})

</code></pre></div><h2 id="中间件-在express-框架里的概念"><a href="#中间件-在express-框架里的概念" aria-hidden="true" class="header-anchor">#</a> 中间件 在Express 框架里的概念</h2> <p>​	中间件是一个可访问请求对象（<code>req</code>）和响应对象（<code>res</code>）的函数，在 Express 应用的请求-响应循环里，下一个内联的中间件通常用变量 <code>next</code> 表示。中间件的功能包括：</p> <ol><li>中间件是一个函数，路由处理函数</li> <li>有一个形参：next：是一个函数</li> <li>在中间件中可以调用这个函数</li> <li>中间件的表现：函数中的形参列表中只要有next函数就是中间件</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function myMiddleWare(req,res,next){
}

</code></pre></div><h3 id="作用："><a href="#作用：" aria-hidden="true" class="header-anchor">#</a> 作用：</h3> <ul><li><p>表示每一个处理环节</p></li> <li><p>这些处理环节之间只负责单独的处理</p></li> <li><p>每当上一个中间件处理完以后，都交给下一个中间件继续处理</p></li> <li><p>中间件之间共享的是req和res这两个对象</p></li> <li><p>在中间件这个函数的参数列表中，有个next函数，这个next函数，只要一</p> <p>被调用，就会进入到下一个中间件的处理环节</p></li></ul> <h3 id="案例："><a href="#案例：" aria-hidden="true" class="header-anchor">#</a> 案例：</h3> <ul><li>日记记录需求：</li> <li>每当有客户端来请求服务器，都要记录下这个请求的时间、</li> <li>url地址、以及请求的方式。</li> <li>格式：2012-12-12  12:12:12  GET/api/postinfo</li></ul> <p>分析：</p> <ul><li>每次处理的函数中写入一个info.txt文件即可</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//所以服务器启动之后：
//事件绑定get事件(可以把它封装起来)
app.get('/',(req,res)=&gt;{
	//调用记录日志方法
    recordLog(req,res)
})

// 封装记录日志方法
function recordLog(req,res){
    const infoStr = `${new Date().toLocaleString()} ${req.method} ${req.url}\n`
    //fs.writeFile：会覆盖；使用fs.appendFile()追加
    file.appendFile(path.join(__dirname,'login/info.txt'),infoStr,err=&gt;{
        if(err) return console.log('记录日志失败')
        console.log('记录日志成功')
    })
}  

</code></pre></div><p>通过中间件函数的方式实现上述功能：</p> <ul><li><p>创建一个中间件函数</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个写入日志的中间件
function myMiddleWareWriteLogs(req,res,next){
    // 设置信息的字符串
    const infoStr = `${new Date().toLocaleString()} ${req.method} ${req.url}\n`
    file.appendFile(path.join(__dirname,'login/info.txt'),infoStr,err=&gt;{
        if(err) return console.log('记录日志失败')
        console.log('记录日志成功')
	    //当记录完毕后，自动进入下一个
	    next();
    })
}

</code></pre></div></li> <li><p>引入这个中间件函数</p> <div class="language- extra-class"><pre class="language-text"><code>//引入中间件函数
app.use(myMiddleWareWriteLogs)

</code></pre></div><p>结论：这样不用每次请求都要调用记录日志方法，只要发起请求就会触发中间件函数</p></li></ul> <h2 id="如何在路由中拿到post提交过来的表单数据？"><a href="#如何在路由中拿到post提交过来的表单数据？" aria-hidden="true" class="header-anchor">#</a> 如何在路由中拿到post提交过来的表单数据？</h2> <ul><li>express并没有这种功能</li></ul> <h3 id="关键思路："><a href="#关键思路：" aria-hidden="true" class="header-anchor">#</a> 关键思路：</h3> <ul><li><strong>每当req的data事件被促发时</strong>，就表示有表单数据过来</li> <li>chunk:片、块是buffer二进制类型</li> <li>data有可能被促发多次，每次拿到一小块chunk就必须拼接一下</li></ul> <h3 id="自定义模拟解析表单数据"><a href="#自定义模拟解析表单数据" aria-hidden="true" class="header-anchor">#</a> 自定义模拟解析表单数据</h3> <p>先创建并启动服务器</p> <p>再创建并引入中间件函数</p> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')
const file = require('fs')
const path = require('path')
//创建服务器
const app = express()
//引入中间块函数
app.use(myMiddleWareWriteLogs)
//引入路由
const router = require('./06.router.js')
app.use(router)
//启动服务器
app.listen(3001,()=&gt;{
    console.log(&quot;http://127.0.0.1:3001&quot;)
})
function myMiddleWareWriteLogs(req,res,next){
    const infoStr = `模拟表单解析时间:${new Date().toLocaleString()}； 请求方式：${req.method}； 请求地址：${req.url}\n`
    file.appendFile(path.join(__dirname,'login/info.txt'),infoStr,err=&gt;{
        if(err) return console.log('记录日志失败!')
        console.log('记录日志成功!')
        next()//别忘了
    })
}
module.exports = myMiddleWareWriteLogs

</code></pre></div><p>引入并启动路由模块（每次请求交给路由模块处理）</p> <div class="language- extra-class"><pre class="language-text"><code>const express = require('express')
//引入解析链接参数方法,查询字符串
const querystring = require('querystring');
const router = express.Router() //创建路由
router.get('/',(req,res)=&gt;{
    res.send(&quot;&lt;h1&gt;这是首页&lt;/h1&gt;&quot;)
})
router.get('/movie.html',(req,res)=&gt;{
    res.send(&quot;&lt;h1&gt;这是电影页&lt;/h1&gt;&quot;)
})
router.post('/about.html',(req,res)=&gt;{
    // 每当req的data事件被促发时，就表示有表单数据过来
    // chunk:片、块是buffer二进制类型
    // data有可能被促发多次，每次拿到一小块chunk就必须拼接一下
    let dataStr='';
        req.on('data',(chunk)=&gt;{
        dataStr+=chunk
    })
    req.on('end',()=&gt;{
        // console.log(dataStr)
        //解析成对象,node提供了方法
        //参数1：必填，参数二：界定键值对符号，默认’&amp;‘，参数三，默认’=’
        const result = querystring.parse(dataStr)
        console.log(result)
        res.send(&quot;&lt;h1&gt;这是使用post请求服务器数据&lt;/h1&gt;&quot;+JSON.stringify(result))
    })
})
module.exports = router


</code></pre></div><p>关键点：</p> <ul><li><p>req的data事件</p> <p>每当req的data事件被促发时，就表示有表单数据过来</p></li> <li><p>引入解析链接参数方法,查询字符串</p> <p>解析成对象</p></li></ul> <h3 id="第三方中间件解析表单数据方法"><a href="#第三方中间件解析表单数据方法" aria-hidden="true" class="header-anchor">#</a> 第三方中间件解析表单数据方法</h3> <ul><li>运行 npm i body-parse -S 安装解析表单数据的</li> <li>导入中间件：const bodyParser = require('body-parser')</li> <li>注册中间件,解析普通键值对数据，false表示不使用扩展模块解析表单数据而使用node内置的querystring模块来解析表单数据：pp.use(bodyParser.urlencoded({extended:false}))</li></ul> <p>自己写的中间件：</p> <div class="language- extra-class"><pre class="language-text"><code>const querystring = require('querystring')

function parseForm(req,res,next){
    let dataStr='';
    //当表单有数据提交时才触发此事件
    req.on('data',(chunk)=&gt;{
        dataStr += chunk
    })
    //数据接收完毕
    req.on('end',()=&gt;{
        //如何将result传递给下一个函数呢？
        const result = querystring.parse(dataStr)
        req.body = result
        next()//接入下一函数
    })
}
//以模块化的形式将parseForm方法暴露出去
module.exports = parseForm


调用方法：
// 导入记录自己解析表单日志的中间件
// const parseForm = require('./07parseFrom.js')
// //注册解析表单中间键
// app.use(parseForm)

</code></pre></div><p>第三方中间件（使用）</p> <div class="language- extra-class"><pre class="language-text"><code>// 导入第三方中间块
const bodyParser = require('body-parser')
// 3、注册中间件,解析普通键值对数据，false表示不使用扩展模块解析表单数据
// 而使用node内置的querystring模块来解析表单数据
app.use(bodyParser.urlencoded({extended:false}))

</code></pre></div><h3 id="路由一定要写在中间件之后"><a href="#路由一定要写在中间件之后" aria-hidden="true" class="header-anchor">#</a> 路由一定要写在中间件之后</h3> <div class="language- extra-class"><pre class="language-text"><code>//引入路由,路由一定要要写在中间件之后
const router = require('./07.router.js')
app.use(router)

</code></pre></div><h3 id="中间件的五种分类"><a href="#中间件的五种分类" aria-hidden="true" class="header-anchor">#</a> 中间件的五种分类</h3> <ol><li>应用级：绑定挂载到app对象上的中间件（函数）</li> <li>路由级：绑定到Router上</li> <li>错误处理：(err,req,res,next)有四个形参的函数</li> <li>内置中间件：express.static是唯一的内置中间件</li> <li>第三方中间件：通过npm安装的中间件</li></ol> <h2 id="模块加载机制"><a href="#模块加载机制" aria-hidden="true" class="header-anchor">#</a> 模块加载机制</h2> <ol><li>只要使用require来加载指定模块必然会加载模块中代码</li> <li>只要加载过的代码，会默认缓存，下次执行会优先从缓存中加载，提高模块运行效率</li></ol> <h3 id="核心模块加载机制"><a href="#核心模块加载机制" aria-hidden="true" class="header-anchor">#</a> 核心模块加载机制</h3> <ol><li>先从缓存中查找，如果有，则直接使用</li> <li>如果缓存中没有，则根据路径标识符，加载本地用户模块并缓存起来，供下次使用</li></ol> <h3 id="第三方模块加载机制"><a href="#第三方模块加载机制" aria-hidden="true" class="header-anchor">#</a> 第三方模块加载机制</h3> <ol><li>先从缓存中查找，如果有，则直接使用</li> <li>如果缓存中没有，则根据第三方模块的路径标识符，加载第三方模块并缓存起来，供下次使用</li></ol> <h3 id="在加载用户模块查找规则"><a href="#在加载用户模块查找规则" aria-hidden="true" class="header-anchor">#</a> 在加载用户模块查找规则</h3> <ol><li>如果没有指定用户后缀名，严格按照指定名称进行查找</li> <li>index -&gt; index.js -&gt; index.json(定义常量接收) -&gt; index.node（报错：不是win32）</li></ol> <h2 id="第三方模块-moment-获取当前日期模块"><a href="#第三方模块-moment-获取当前日期模块" aria-hidden="true" class="header-anchor">#</a> 第三方模块(moment)  获取当前日期模块</h2> <ul><li>npm i moment，项目路径下安装</li> <li>这个函数能不能叫一个包？是，有标准的包结构</li></ul> <h2 id="模块查找规则："><a href="#模块查找规则：" aria-hidden="true" class="header-anchor">#</a> 模块查找规则：</h2> <ul><li>1、根据包名称，直接在项目更目录中，去查找一个叫做“node_modules”的文件夹</li> <li>2、如果有，则在该文件夹中，继续查找，一个叫做模块引用的文件夹</li> <li>3、如果有，则在对应文件夹中查找'package.json'的文件</li> <li>4、如果有该文件，则查找其中main属性并尝试加载main指定的文件作为入口、</li> <li>5、能正常加载main指定文件则加载成功</li> <li>6、如果在packge.json文件中没有main属性，则尝试依次加载根目录中的index.js,index.json,inde.node文件</li> <li>7、如果在包的根目录中，根本没有packge.json文件，或者在“node_modules”中没有index相关文件,或者根本没有对应文件夹，或者在项目根目录中根本无node_modules则会向上一层去查找node_modules，查找规则同上</li> <li>8、如果上一层目录中还是没有对应模块，则继续上找直到找到项目所在的磁盘根目录中还没找到就报错</li></ul> <h1 id="node中使用mysql数据库"><a href="#node中使用mysql数据库" aria-hidden="true" class="header-anchor">#</a> node中使用mysql数据库</h1> <ol><li><p>安装mysql模块: nom i mysql -S</p></li> <li><p>导入模块：const mysql = require('maysql')</p> <div class="language- extra-class"><pre class="language-text"><code>//导入数据库模块
const mysql = require('mysql')

</code></pre></div></li> <li><p>创建连接对象</p> <div class="language- extra-class"><pre class="language-text"><code>// 创建数据库连接对象
const conn = mysql.createConnection({
    host:'127.0.0.1',
    user:'root',
    password:'root',
    database:'myuser'
})

</code></pre></div></li> <li><p>调用connect()连接上数据库的服务器</p> <div class="language- extra-class"><pre class="language-text"><code>//连接数据库，可不写
conn.connect()

</code></pre></div></li> <li><p>调用conn.query()方法来执行指定的SQL语句</p> <div class="language- extra-class"><pre class="language-text"><code>//执行查询语句
const sqlStr='select * from info'
conn.query(sqlStr,(err,result)=&gt;{
    console.log(err)
    console.log(result)
})

</code></pre></div><p>[art-template 官方文档](https://aui.github.io/art-template/zh-cn/docs/index.html</p></li></ol> <h2 id="ceud操作：增删改查"><a href="#ceud操作：增删改查" aria-hidden="true" class="header-anchor">#</a> CEUD操作：增删改查</h2> <div class="language- extra-class"><pre class="language-text"><code>const sqlStr=&quot;insert into info set ?&quot;  //增
const sqlStr=&quot;delete from info  where id = 1&quot;  //删
const sqlStr=&quot;update info set name='沈阳' where id = 0&quot;  //改

</code></pre></div><p>在执行语句时，对于后接的参数，可以用问号代替</p> <div class="language- extra-class"><pre class="language-text"><code>const sqlStr=&quot;insert into stu_info set ?&quot;
将参数数据写在 query() 方法中
conn.query(sqlStr,数据对象,(err,result)=&gt;{
    console.log(err)
    console.log(result)
})

</code></pre></div><p>注意：企业级项目开发，不建议使用delete删除数据，
可以通过添加isdel字段属性来标识数据是否删除（软删除）</p> <div class="language- extra-class"><pre class="language-text"><code>例如：updated users set isdel = 1 where id = 2

</code></pre></div><h1 id="express中获取参数的几种形式"><a href="#express中获取参数的几种形式" aria-hidden="true" class="header-anchor">#</a> express中获取参数的几种形式</h1> <h2 id="从url地址中获取查询参数"><a href="#从url地址中获取查询参数" aria-hidden="true" class="header-anchor">#</a> 从URL地址中获取查询参数</h2> <div class="language- extra-class"><pre class="language-text"><code>app.get(&quot;/index.html&quot;,(req,res)=&gt;{
    res.send('ok')
    console.log(req.query)
})
//浏览器输入
http://127.0.0.1:3000/index.html?id=1

</code></pre></div><h2 id="从url地址路径中获取"><a href="#从url地址路径中获取" aria-hidden="true" class="header-anchor">#</a> 从URL地址路径中获取</h2> <div class="language- extra-class"><pre class="language-text"><code>app.get(&quot;/userinfo/:id/:name&quot;,(req,res)=&gt;{
    console.log(req.params)
})
//浏览器输入
http://127.0.0.1:3000/userinfo/1/熊刚

</code></pre></div><h2 id="从post表单中获取提交的数据"><a href="#从post表单中获取提交的数据" aria-hidden="true" class="header-anchor">#</a> 从post表单中获取提交的数据</h2> <div class="language- extra-class"><pre class="language-text"><code>//先引入第三方中间件
const bodyParse = require('body-parser')
app.use(bodyParse.urlencoded({extended:false}))
//无法请求
app.get(&quot;/index.html&quot;,(req,res)=&gt;{
    console.log(req.query)
})
浏览器输入：http://127.0.0.1:3000/index.html?id=2&amp;name=熊刚

</code></pre></div><h1 id="企业两种开发模式"><a href="#企业两种开发模式" aria-hidden="true" class="header-anchor">#</a> 企业两种开发模式</h1> <h2 id="混合模式"><a href="#混合模式" aria-hidden="true" class="header-anchor">#</a> 混合模式</h2> <ul><li>前端只需要美化样式，写js特效</li></ul> <h2 id="前后端分离"><a href="#前后端分离" aria-hidden="true" class="header-anchor">#</a> 前后端分离</h2> <ul><li>后端负责操作数据库，给前端暴露接口，渲染页面，前端就可以使用一些流行的框架：如vue,react,angluar</li></ul> <h2 id="跨域问题"><a href="#跨域问题" aria-hidden="true" class="header-anchor">#</a> 跨域问题</h2> <ul><li>如果不考虑 表单的 Post 提交，则 可以使用 JSONP的形式来请求接口</li> <li>但是，我们的项目中，涉及到了 英雄表单的 提交，表单提交一般都是Post</li> <li>经过分析，由于JSONP，不支持Post，所以，我们的后端接口，无法设计成JSONP的接口；</li></ul> <h2 id="jsonp-和-cors-的区别"><a href="#jsonp-和-cors-的区别" aria-hidden="true" class="header-anchor">#</a> JSONP 和 CORS 的区别</h2> <p>1、JSONP的原理：动态创建script标签；</p> <ul><li>JSONP发送的不是Ajax请求</li> <li>不支持 Post 请求；</li></ul> <p>2.CORS中文意思是<code>跨域资源共享</code> , 本质，就是使用 XHR 对象，发送Ajax请求，来进行跨域的资源共享；</p> <ul><li>CORS 发送的是真正的Ajax请求</li> <li>CORS 支持Ajax的跨域</li> <li>如果要启用 CORS 跨域资源共享，关键在于 服务器端，只要 服务器支持CORS跨域资源共享，则 浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在 发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化；</li></ul> <p>3、对于Node来说，如果想要开启 CORS 跨域通信，只需要安装<code>cors</code>的模块即可；jax的时候，就像发送普通AJax一样，没有任何代码上的变化；</p> <div class="language- extra-class"><pre class="language-text"><code>npm i cors -S
// 导入CORS模块
const cors = require('cors')
// 开启客户端跨域服务
app.use(cors())

</code></pre></div><h2 id="英雄接口"><a href="#英雄接口" aria-hidden="true" class="header-anchor">#</a> 英雄接口</h2> <h3 id="准备工作"><a href="#准备工作" aria-hidden="true" class="header-anchor">#</a> 准备工作</h3> <div class="language- extra-class"><pre class="language-text"><code>npm init -y初始化项目
npm i express -S
npm i mysql -S

</code></pre></div><p>1、server文件夹:服务器文件</p> <ul><li>server.js服务器端入口文件</li></ul> <p>2、web文件夹：页面代码</p> <ul><li>web.js页面入口文件</li></ul> <h4 id="安装"><a href="#安装" aria-hidden="true" class="header-anchor">#</a> 安装</h4> <div class="language- extra-class"><pre class="language-text"><code>//views文件夹-》index.html安装模版引擎
npm i art-template -S
//安装bootstrap美化
npm i bootstrap@3 -S


</code></pre></div><h3 id="知识点："><a href="#知识点：" aria-hidden="true" class="header-anchor">#</a> 知识点：</h3> <ol><li><p>res.json();自动把对象转换为json字符串</p></li> <li><p>e.preventDefault();阻止表单默认提交</p></li> <li><p>location.href=&quot;/&quot;   //跳转回首页</p></li> <li><p>$(&quot;form&quot;).serialize()//表单中所有数据，并序列化一下</p> <div class="language- extra-class"><pre class="language-text"><code>$.ajax({
      url:&quot;http://127.0.0.1:5000/api/addhero&quot;,
      data:$(&quot;form&quot;).serialize(),
      type:&quot;post&quot;,
      dataType:&quot;json&quot;,
      success:function(result){
         console.log(result);
      }
})

</code></pre></div><p>​</p></li></ol> <h3 id="思路："><a href="#思路：" aria-hidden="true" class="header-anchor">#</a> 思路：</h3> <ul><li>1、创建一个最基本express服务器，作用：不提供web服务。</li> <li>而是提供一个数据接口接口服务；</li> <li>2、安装cors模块，从而启用跨域资源共享；</li> <li>3、安装mysql模块来操作数据库；</li> <li>4、根据api设计文档来创建对应接口，在接口api中，如果返回json</li> <li>数据，使用res.json()</li> <li>5、再设计更新英雄时安装body-parser中间件，来解析表单数据</li></ul> <h3 id="如何拿到get提交过来数据"><a href="#如何拿到get提交过来数据" aria-hidden="true" class="header-anchor">#</a> 如何拿到get提交过来数据</h3> <ul><li>const id = req.query.id</li></ul> <h3 id="第三方模块也可以发送ajax"><a href="#第三方模块也可以发送ajax" aria-hidden="true" class="header-anchor">#</a> 第三方模块也可以发送ajax</h3> <ul><li>axios专门发送ajax的</li> <li>前后端都可以使用，</li> <li>基于promis封装的</li></ul> <p>安装，将资源托管到页面</p> <div class="language- extra-class"><pre class="language-text"><code>//导入所有功能资源：jquery，axios等
app.use('/node_modules',express.static(&quot;../node_modules&quot;))

</code></pre></div><p>再引用</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;/node_modules/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/node_modules/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;

</code></pre></div><p>发送ajax的时候可以使用：</p> <div class="language- extra-class"><pre class="language-text"><code> // $(&quot;form&quot;).serialize()//表单中所有数据，并序列化一下
                // name=李白&amp;gender=男=》格式
                axios.post(&quot;http://127.0.0.1:5000/api/addhero&quot;,$(&quot;form&quot;).serialize())
                .then(function(result){
                if(result.status == 200 &amp;&amp; result.data.err_code === 0) {
                    location.href=&quot;/&quot;;
                } else {
                    alert('添加失败！');
                }
                })

</code></pre></div><h2 id="文章"><a href="#文章" aria-hidden="true" class="header-anchor">#</a> 文章</h2> <ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">跨域资源共享 CORS 详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/expressjs/cors" target="_blank" rel="noopener noreferrer">cors模块解决Node跨域资源共享问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h1 id="mvc"><a href="#mvc" aria-hidden="true" class="header-anchor">#</a> MVC</h1> <ol><li>M:数据操作层(例如:model.js);</li> <li>C:业务逻辑操作层（例如：router.js和controller;</li> <li>V:views视图层，页面</li></ol> <h2 id="作用：-2"><a href="#作用：-2" aria-hidden="true" class="header-anchor">#</a> 作用：</h2> <ul><li>能够保证每个模块只能单一，提高项目的维护和开发性；</li> <li>注意：MVC是后端分层开发思想，所以，MVC是整个项目的角度，去分析统筹前端页面，</li> <li>与后端业务逻辑，后端数据操作之间的关系；</li> <li>注意：VUE，使用了MVVM的开发思想，只关注前端视图层，只是把每个前端页面</li> <li>分成三层，分别是M 、 V 、 VM</li></ul> <div class="language- extra-class"><pre class="language-text"><code>M：保存页面单独数据 
V：每个页面的html结构
VM：调度者，分隔了M和V。每当V层想要获取后保存数据的时候，需要vm做中间处理

</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/gangking/myBlog/edit/master/docs/node/nodeJs.md" target="_blank" rel="noopener noreferrer">编辑文档</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2019-8-11 01:04:14</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myBlog/node/" class="prev router-link-active">
          介绍
        </a></span> <span class="next"><a href="/myBlog/node/CodeManagement.html">
          代码管理工具
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/myBlog/assets/js/app.9a205e1a.js" defer></script><script src="/myBlog/assets/js/2.c03f67b8.js" defer></script><script src="/myBlog/assets/js/21.6daa352d.js" defer></script>
  </body>
</html>
